<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>如何写一份技术简历</title>
    <link href="/2020/03/31/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E6%8A%80%E6%9C%AF%E7%AE%80%E5%8E%86/"/>
    <url>/2020/03/31/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E6%8A%80%E6%9C%AF%E7%AE%80%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h5 id="最近这段时间因为公司一直在招人，负责公司的一面，因此看了很多的简历，发现不会写简历的人真的特别的多。各种奇奇怪怪得问题都有。因此准备吐槽一下从一个开发的角度来看好的简历应该是怎么样的"><a href="#最近这段时间因为公司一直在招人，负责公司的一面，因此看了很多的简历，发现不会写简历的人真的特别的多。各种奇奇怪怪得问题都有。因此准备吐槽一下从一个开发的角度来看好的简历应该是怎么样的" class="headerlink" title="最近这段时间因为公司一直在招人，负责公司的一面，因此看了很多的简历，发现不会写简历的人真的特别的多。各种奇奇怪怪得问题都有。因此准备吐槽一下从一个开发的角度来看好的简历应该是怎么样的"></a>最近这段时间因为公司一直在招人，负责公司的一面，因此看了很多的简历，发现不会写简历的人真的特别的多。各种奇奇怪怪得问题都有。因此准备吐槽一下从一个开发的角度来看好的简历应该是怎么样的</h5><ol><li>简历中不要出现专有名词的书写错误，比如 android IOS 之类的拼写错误</li><li>不要大篇幅的描述你所做的公司的项目，其实对你公司做什么并没有什么特别的兴趣，你做了什么才是关键的</li><li>描述所做工作的时候，如果几份工作经历所做的技术栈都是比较类似的，建议酌情删除，因为会让人觉得你是一份工作经验用了多年</li><li>对于所做工作要拿出一个能够衡量的指标出来，所谓的拿数据说话，比如做过性能优化相关的工作，可以改成优化性能，某某功能的内存占用，启动速度提升了 xx% 这样的数据，口说无凭但数据是不会骗人的</li><li>简历中写到用到的技术，一定要自己搞清楚原理，不要被别人问起来什么都是会用，什么都不知道，这样就一直只会搬砖了</li><li>不要写一堆精通 C++，Java，JVM 之类的词，除非你真精通，不然写熟悉就好。写一堆精通没啥用</li><li>如果你 GitHub 是空的，或者博客限闲置了大半年，且之前也没有什么好的内容的话。没必要贴上来，贴个空的 GitHub 要干嘛呢？说明你会用 Git ？</li><li>简历最好不要超过 2 页，多了其实看不了那么多，大部分普通人也没有那么多可写的</li><li>简历 PDF 和 Word 格式的都备着，优先给 PDF</li><li>不是相亲，如果你不是长的特别帅/美的话不需要放照片</li><li>简历只是第一印象，最重要的还是自己本身技术知识的沉淀</li></ol><h5 id="其他的"><a href="#其他的" class="headerlink" title="其他的"></a>其他的</h5><ul><li>简历写的好只是让通过筛选的可能性变大，但是终归还是要靠自己技术的。不要用公司技术栈的原因作为自己不进取的理由，如果公司的项目亮点不多的话，开源项目也是可以做敲门砖的。</li><li>对程序的热情也是不会骗人的，喜欢一件事和不喜欢是完全不一样的</li><li>大学时候读博客的时候就看到过一篇博客写的就是如何去改善技术简历，对我帮助非常大。原文连接已经失效，可以通过搜索标题去查找</li><li><a href="http://zh.lucida.me/blog/lean-technical-resume" target="_blank" rel="noopener">精益技术简历之道——改善技术简历的47条原则</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>简历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重新开始</title>
    <link href="/2020/02/23/%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B/"/>
    <url>/2020/02/23/%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B/</url>
    
    <content type="html"><![CDATA[<ul><li><p>算是重新开始写博客了吧，试过了自己搭服务器，用 typecho 搭一个简单的博客平台，但是都没有坚持下去，最后还是用回了 GitHub page ，毕竟内容才是最重要的。另外域名也换掉了，改成了 xiongzb.com 但是还没有备案，所以博客里面暂时也用不了七牛的免费 cdn，可能会有点慢，后续有空把这个给优化一下好了</p></li><li><p>距离上一次写日志 2017.1.1 ，现在在这家公司也已经待了三年了。不管是技术上还是生活上都有了很大的改变。 10 年前的我估计怎么样都想不到原来的我 27 岁时这样的，哈哈，继续加油吧，毕竟不努力在互联网这行说不定 35 就被优化掉了呢😂</p></li><li><p>过年的时候定了一下今年个人的 OKRs，很多东西都需要继续努力。最近我也会逐渐的把我之前记录的笔记重新整理成文章发出来，算是个人的一个简单记录吧</p></li><li><p>反正都是个人的一些碎碎念，加油吧！</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android X 项目迁移</title>
    <link href="/2020/02/23/%E9%A1%B9%E7%9B%AE%E8%BF%81%E7%A7%BB/"/>
    <url>/2020/02/23/%E9%A1%B9%E7%9B%AE%E8%BF%81%E7%A7%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是-Android-X"><a href="#什么是-Android-X" class="headerlink" title="什么是 Android X"></a>什么是 Android X</h3><ul><li>Android X 是 Google 推出的一系列兼容包以及工具库，之前的 support 包被拆分成为了多个库，包括新的 JetPack 开发工具库其实也算做是 Android X 的一部分</li></ul><h3 id="为什么要迁移"><a href="#为什么要迁移" class="headerlink" title="为什么要迁移"></a>为什么要迁移</h3><ul><li>support 包不再维护，bug 不能及时维护</li><li>新的库比如 ViewPager2 都是基于 Android X 的 RecyclerView，如果不升级无法使用</li><li>海外项目涉及到 Google 相关的库比如支付/登陆/ play service 等都已经升级，如果你不跟着升级会有很多冲突，而且一些海外的第三方库都要求你依赖 gms，如果不升级会有很多问题</li></ul><hr><h3 id="建议什么项目怎么迁移"><a href="#建议什么项目怎么迁移" class="headerlink" title="建议什么项目怎么迁移"></a>建议什么项目怎么迁移</h3><ul><li>海外项目建议尽快迁移</li></ul><hr><h3 id="官方迁移指南"><a href="#官方迁移指南" class="headerlink" title="官方迁移指南"></a>官方迁移指南</h3><ul><li><a href="https://www.bilibili.com/video/av74729260" target="_blank" rel="noopener">B 站视频</a></li><li><a href="https://developer.android.com/jetpack/androidx/migrate" target="_blank" rel="noopener">官方文档</a></li><li>官方简易文字指南<ul><li>如果之前 support 包没有升级到 28，请先全部升级到 28</li><li>gradle.properties 中添加 android.useAndroidX=true 和 android.enableJetifier=true 两个属性</li><li><del>同步后使用 Android Studio 的一键迁移到 AndroidX</del></li></ul></li></ul><hr><h3 id="迁移过程中的一些坑"><a href="#迁移过程中的一些坑" class="headerlink" title="迁移过程中的一些坑"></a>迁移过程中的一些坑</h3><ul><li>不要使用 Android Studio 自带的一键迁移，会出现很多包名对不上的情况,公司的项目迁移后的很多类的包名都是错误的</li><li>建议直接参考 <a href="https://developer.android.com/jetpack/androidx/migrate/class-mappings" target="_blank" rel="noopener">class mapping</a> 全局搜索替换类的包名，这样简单粗暴不会有任何问题。xml 记得也要替换</li><li>部分第三方库比如 Glide，butterknife 升级到 Android X 可能会发生崩溃，去查对应库的 issue 升级即可</li><li>升级过后需要把应用内的功能全部回归测试一遍，避免出现任何问题，迁移工作加上测试大致 2 天左右，建议单独抽出两天时间不要做新功能专门做这个升级</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2016 总结</title>
    <link href="/2017/01/01/2016%20%E6%80%BB%E7%BB%93/"/>
    <url>/2017/01/01/2016%20%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>今天是 2017.1.1 准备把之前开坑的 2016 年总结给填了。</p><p>2016 年总体是在不断变化的一年，又主动的有被动的，有好的有坏的。这一年虽然不算过的平静但是好歹也结束了。</p><a id="more"></a><hr><h4 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h4><p>没什么好说的，大致就是换了一家更好的公司吧</p><p><del>2016 年开年的时候在前公司工作的第二年，年初的时候还是信心满满的准备好好工作，结果到年中的时候经常没事做，大概感觉到了公司要挂，所以从 10 月份开始就在准备找工作了，结果 11 月份公司就裁人了。被杀了个措手不及，但是多亏了这次找到了现在新的工作，到现在也已经工作了一个月的时间了，工作上有挑战，同事也很好，希望在接下来的一年能够更好的工作。</del></p><hr><h4 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h4><p>这一年看了挺多的书，但是也有些当初没有完成的目标。另外一个比较大的收获就是开源了 Bgm38 ，当初是个玩票性质加练习的作品，结果收获了好几百的 star，还是挺开心的。</p><hr><h4 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h4><p>这一年努力的想让自己的生活过的更好一些，买了一些数码装备也卖掉了一些不需要的装备。黑卡3，6s，iPad mini4。其它的卖掉了闲置的 PS4,捡起了之前的 new 3ds。不过体重倒是没怎么变，整体是在变好的过程。</p><hr><p>新的一年给自己定的目标有几个： 减肥，看更多的书，生活过的更好，更多的旅行</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OAuth2.0 简介</title>
    <link href="/2016/10/24/oauth2.0%E7%AE%80%E4%BB%8B/"/>
    <url>/2016/10/24/oauth2.0%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>其实这篇文章是很早以前就记在为知笔记里面的，但是一直懒的重新整理，但是不久前有人在群里面问 oauth2.0 相关的问题，就想着整理一遍出来了，好了，下面开始写正文了要是发现有什么错误，欢迎在评论里面指出。</p><a id="more"></a><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><a href="https://en.wikipedia.org/wiki/OAuth#OAuth_2.0" target="_blank" rel="noopener">OAuth2.0</a>是比较常用的一种第三方协议，比如我们在很多 APP 上面都有看到除了自家的账户还提供微博，QQ 登录这样的登录方式。像这些第三方登录都是使用的 OAuth2.0 登录的。那么为什么要用这种登录方式呢？下面我们举个例子来说明。</p><hr><h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p>比如我们在使用一个第三方的 APP 的时候，有时候想偷懒不想注册新用户，想要直接用 QQ 登录节省时间，但是 QQ 不会那么傻直接把账号给第三方吧，不然账号一不小心就泄露了。这时候就是用 OAuth2.0 的时候了，QQ 只给一个 accessToken 给第三方，第三方在向 QQ 请求的时候把 token 一起传递过去，这样就避免了把账号密码给暴露，实际的操作还是在 QQ 的服务器上完成，同时 QQ 的服务器还能随时将 token 置为过期避免滥用账号保证了安全。通过这个例子基本上就可以了解 OAuth2.0 的作用的。</p><hr><h4 id="流程说明"><a href="#流程说明" class="headerlink" title="流程说明"></a>流程说明</h4><p>接下来我们了解下整个过程： <a href="http://www.rfcreader.com/#rfc6749_line259" target="_blank" rel="noopener">图片地址</a></p><p><img src="http://7xjkin.com1.z0.glb.clouddn.com/oauth1.jpg" srcset="/img/loading.gif" alt=""></p><p>我们还是以手机上第三方以QQ登录为例：Client 就是我，右边的可以理解为 QQ 。我们的目的是登录 QQ 并获取我的 QQ 好友列表<br>A： 我做了一个 APP ，里面接入了 QQ 登录。打开 APP 点击 QQ 登录，可能跳转至 QQ 或者网页登录（没有安装 QQ ）<br>B： 登录了账号并点击了同意，向我授权了可以去申请 token 了并且返回了 code<br>C： 我在客户端里面拿上一步授权返回的 code 向 QQ 申请拿 token<br>D： QQ 检查了 code 之后发现是正常的，向我返回了 token<br>E： 拿到了 token 之后，向 QQ 发送请求获取我的 QQ 好友，记得要带上 token<br>F： QQ 获取到我们的请求后，检查 token 是否正常（是否过期，错误等），正常的情况下会返回好友列表</p><p>上面的A-F基本上就是我们在OAuth登录的时候会做事情，介绍的是授权码模式模式，这种模式是最完整，流程最严密的授权模式。这一篇文章就只会介绍这种模式，其他的几种模式可以参考<a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">阮一峰的博客</a>。</p><hr><h4 id="具体数据流程"><a href="#具体数据流程" class="headerlink" title="具体数据流程"></a>具体数据流程</h4><p>下面具体在介绍下整个流程中请求包及返回的数据：</p><p>一般我们 OAuth2.0 登录的时候都需要先申请账号先，当然也有可能是 client 和 server 两边都是自己。申请成功后会分配给你一个 clientId，clientSecret。同时还会要你配置一个 redirectUri 跳转 url。故名思议跳转 url 就是用来跳转会自己的 app 的，网页上就是跳转会之前的登录页面。<br>A:  传递 client_id， response_type=code（这一项是固定的值为code），redirect_uri<br>B: 一般是跳转到配置的 url 并返回 code<br>C: 拿到了 code，去请求拿 token，传 code， grant_type（值默认为authorization_code），redirect_uri，client_id，client_secret<br>D: 返回 token<br>E-F： 这部分就没什么好说了，带上token去请求即可<br>详细的可以参考<a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">阮一峰的博客</a>。但是在介绍 C 那步中，它并没有说要传 client_secret。尝试过后发现不传的话始终拿不到 token。同时在测试的时候 C 步骤由于使用了 https 的地址，但是网页并没有做加密导致一直返回下面下面的错误 javax.net.ssl.SSLPeerUnverifiedException: Hostname diycode.cc not verified:</p><p>更新accesstoken：以diycode 为例，每次下发的token信息如下所示</p><pre><code class="xml">{&quot;access_token&quot;:&quot;b37c7197df69bc5f56f4241079464588728a43d9876c9057bf98fab42da87067&quot;,&quot;token_type&quot;:&quot;bearer&quot;,&quot;expires_in&quot;:86400,&quot;refresh_token&quot;:&quot;a021d136245c566608008403cc0d3b07822ef5ec14ac71f312ee775fe4d25078&quot;,&quot;created_at&quot;:1465358312}</code></pre><p>其中 expires_in 过期时间为86400s，即24h。这样的话在下次访问的嘶吼，客户端收到 token 过期，需要用 refresh token 重新申请。传递的参数可以参考下面 postman 模拟的参数</p><p>如果不手动更新，过期访问的时候会返回 http status： 401 - 用户认证失败，或缺少认证信息，比如 access_token 过期，或没传，可以尝试用 refresh_token 方式获得新的 access_token。</p><p><img src="http://7xjkin.com1.z0.glb.clouddn.com/oauth2.png" srcset="/img/loading.gif" alt=""></p><hr><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><p>原理介绍的差不多了，写一个 demo 测试，API 是根据 diycode.cc 网站提供的，原本是打算做客户端的，但是 API 一直不是很稳定，所以就搁浅了只做了一个登录的功能，可以去我写的 demo 地址查看,如果觉得不错可以顺手 star 一个。</p><p><a href="https://github.com/zubinxiong/DC4Android" target="_blank" rel="noopener">Github demo 地址</a></p><hr><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://futurestud.io/blog/oauth-2-on-android-with-retrofit" target="_blank" rel="noopener">https://futurestud.io/blog/oauth-2-on-android-with-retrofit</a><br><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a></p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>oauth2.0</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bgm38 踩坑备忘</title>
    <link href="/2016/09/12/Bgm38%20%E8%B8%A9%E5%9D%91%E5%A4%87%E5%BF%98/"/>
    <url>/2016/09/12/Bgm38%20%E8%B8%A9%E5%9D%91%E5%A4%87%E5%BF%98/</url>
    
    <content type="html"><![CDATA[<p>之前在写 <a href="http://ewriter.me/2016/08/18/bgm38/" target="_blank" rel="noopener">Bgm38</a> 的时候，遇到了不少的坑。之前也说过了最开始写的时候基本没考虑维护性就是想怎么写就怎么来，最近开始重构成目前流行的 MVP + RxJava + Retrofit 的形式，这篇文章主要就是记录下这个过程中遇到的一些问题作为备忘</p><a id="more"></a><ul><li>BottomSheetDialog 手动向下滑动后无法再展开，<a href="http://blog.csdn.net/yanzhenjie1003/article/details/51938400" target="_blank" rel="noopener">解决方法</a></li><li>SwipeRefresh 必须在 onMeasure 后调用刷新显示，放在 post 中执行</li><li>okHttp 中的 response.body().string() 方法是会消耗 body 的，导致后面再调用该方法时始终为空</li><li>viewpager 的 setAdapter 方法时异步的，如果在 setAdapter 后立刻调用刷新可能此时子 fragment 还没来得及初始化导致为空，<a href="http://stackoverflow.com/questions/7700226/display-fragment-viewpager-within-a-fragment" target="_blank" rel="noopener">解决方法</a></li><li>Fragment <a href="http://www.jianshu.com/p/d9143a92ad94" target="_blank" rel="noopener">相关坑及解决方法</a></li><li>RxJava 实现 EventBus 效果，包括普通 event 及 sticky 。<a href="http://www.jianshu.com/p/71ab00a2677b" target="_blank" rel="noopener">参考文章</a></li><li>Retrofit 使用 @Url 参数，使用这个参数同时不能使用其它参数，如 @Query 等，@Url 指定的是一个绝对链接，不再接受其它的参数，同时它也会忽视设置的 baseUrl。更多具体的文章可以查看文档或<a href="https://futurestud.io/tutorials/retrofit-2-how-to-use-dynamic-urls-for-requests" target="_blank" rel="noopener">这篇文章</a></li><li>Retrofit 同时含有两个 baseUrl, 一种做法是直接定义两个 retrofit ，另外是通过 okHttp 的 interceptor 拦截，每次运行的时候动态的指定 baseUrl。Github 上的 issues 也有人提过这个问题。<a href="https://github.com/square/retrofit/issues/1404#issuecomment-207408548" target="_blank" rel="noopener">链接</a></li><li>Jsoup 抓取网页数据，因为返回来的数据是 html 即 String，因此我们不能使用常用的 GsonFormat，这时候可以自己重写 Converter 或者使用 Retrofit 提供给我们的 <a href="https://github.com/square/retrofit/tree/master/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars" target="_blank" rel="noopener">scalars</a> </li></ul><hr><p>下列待补充</p><ul><li>使用 LeakCanary 发现的 InputMethod 的内存泄漏</li><li>MVP 模式相关使用</li><li>RxJava 相关</li></ul><hr><p><a href="https://github.com/zubinxiong/Bgm38" target="_blank" rel="noopener">Bgm38 地址</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ViewPager 切换动画</title>
    <link href="/2016/09/04/ViewPager%20%E5%88%87%E6%8D%A2%E5%8A%A8%E7%94%BB/"/>
    <url>/2016/09/04/ViewPager%20%E5%88%87%E6%8D%A2%E5%8A%A8%E7%94%BB/</url>
    
    <content type="html"><![CDATA[<p>在 <a href="http://gank.io" target="_blank" rel="noopener">Gank</a> 上看到了 <a href="https://github.com/rubensousa/ViewPagerCards" target="_blank" rel="noopener">ViewPagerCards</a> 这个项目，觉得挺好看的，就看了下源码。</p><a id="more"></a><hr><p>关于这个 demo 里面的效果有两个地方需要注意的:一个就是切换时的动画效果和同时显示多个page页面</p><ul><li><p>动画效果开始以为是通过ViewPager 的  setPageTransformer 方法实现的，看来下代码虽然有设置，但里面的实现方法是空的，实际上是通过 addScrollListener 的效果实现的，如何使用动画看<a href="http://blog.csdn.net/wei_smile/article/details/51167220" target="_blank" rel="noopener">这篇文章</a></p></li><li><p>同时显示多个是通过 设置 viewpager 的 padding 以及 clipToPadding 这种属性配合实现的。对后面属性不熟悉的可以看这篇<a href="http://www.alloyteam.com/2014/10/androidcliptopadding-he-androidclipchildren/" target="_blank" rel="noopener">文章</a></p></li></ul><hr><p>这篇文章就不主要介绍上面的方法了，主要是想要介绍如何自定义 ViewPager 的动画</p><p>以知乎的为例子，文字逐渐消失及滚动的效果。实现了顶部全透明和带有阴影两种</p><p>在做的时候遇到下面的问题:</p><ul><li>一个是viewpager 设置了style 是透明，但是顶上确一直是一条白色的背景，显示的其实是 activity 的背景，全透明解决方法是在 viewpager 外面套一层 ScrimInsetsFrameLayout 和 CoordinatorLayout; 半透明不用，然后去掉所有的fitSystemWindow 参考 <a href="https://github.com/matrixxun/ProductTour" target="_blank" rel="noopener">ProductTour</a></li><li>动画必须等待移动结束才开始执行，原因是没有把位移参数算进去，导致出现问题，但这样计算的话有些复杂，如果简单的动画可以直接改变 view 的大小解决</li></ul><hr><p>Github <a href="https://github.com/zubinxiong/LifeWithAndroid/tree/master/zhihuwelcome" target="_blank" rel="noopener">Demo 地址</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bgm38 Android 客户端</title>
    <link href="/2016/08/18/bgm38/"/>
    <url>/2016/08/18/bgm38/</url>
    
    <content type="html"><![CDATA[<h3 id="Bgm38客户端"><a href="#Bgm38客户端" class="headerlink" title="Bgm38客户端"></a>Bgm38客户端</h3><ul><li><p>上周？上上周？反正是大概是这段时间，做了一个 <a href="http://bangumi.tv" target="_blank" rel="noopener">bangumi</a> 的第三方 Android 客户端，其实之前也已经有一个客户端了。但是作者好像不做 Android 开发了，所以就自己重头做了一个</p></li><li><p>目前 App 已经在应用宝上线了，Google play 的话等我周末把信用卡给开通再来弄好了，地址的话稍后</p></li></ul><a id="more"></a><ul><li><p>在做这个App 的时候特意没有采用什么 RxJava ，MVP 这种稍微新的技术，直接用的 MVC, Eventbus,也基本没有进行封装。结果写到后面就发现坑好多，很多地方的逻辑变得非常复杂。以至于我差点想在发出去之前重写。虽然忍住了，不过重构也是在所难免。</p></li><li><p>关于 App 的功能，其实没什么好说的。限于 API 的原因，很多网页上的功能都没有实现。必须要手动去抓取。这些就只能留到后面去实现了，虽然不知道这个后面要多久，但暂时还是不会弃坑的。</p></li><li><p>最后不要脸的欢迎各位去 Github start一波。 <a href="https://github.com/zubinxiong/Bgm38" target="_blank" rel="noopener">Github 地址</a></p></li></ul><hr><h3 id="图片预览"><a href="#图片预览" class="headerlink" title="图片预览"></a>图片预览</h3><table><thead><tr><th>我的进度</th><th>详情</th><th>每日更新</th><th>标记状态</th><th>超展开</th></tr></thead><tbody><tr><td><img src="http://7xjkin.com1.z0.glb.clouddn.com/bgm4.jpg" srcset="/img/loading.gif" alt=""></td><td><img src="http://7xjkin.com1.z0.glb.clouddn.com/bgm2.jpg" srcset="/img/loading.gif" alt=""></td><td><img src="http://7xjkin.com1.z0.glb.clouddn.com/bgm1.jpg" srcset="/img/loading.gif" alt=""></td><td><img src="http://7xjkin.com1.z0.glb.clouddn.com/bmg3.jpg" srcset="/img/loading.gif" alt=""></td><td><img src="http://7xjkin.com1.z0.glb.clouddn.com/bgm5.jpg" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><hr><h3 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h3><ul><li>App 的图标由 <a href="http://bangumi.tv/user/buernia" target="_blank" rel="noopener">奈白不弍</a> 设计</li><li>部分界面参考了 <a href="https://github.com/scarletsky/Bangumi-Android" target="_blank" rel="noopener">scarletsky</a> 的项目，loading 界面的图片使用了它的资源</li></ul><hr><h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><p><a href="http://a.app.qq.com/o/simple.jsp?pkgname=me.ewriter.bangumitv" target="_blank" rel="noopener">应用宝</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android SD 卡读写文件</title>
    <link href="/2016/07/25/SD%E5%8D%A1%E8%AF%BB%E5%86%99/"/>
    <url>/2016/07/25/SD%E5%8D%A1%E8%AF%BB%E5%86%99/</url>
    
    <content type="html"><![CDATA[<p>这片文章主要讲解的是 Android 上关于 SD 卡读写的东西，并没涉及到太底层的东西，只有一些坑而已。Android 上最开始是有 API 读取 SD 卡的，就是通过 <strong>Enviroment.getExternalStorageDirectory()</strong> 这个方法获取的，但是后来三星学习苹果在手机内部焊死了一块存储，也就是我们现在通常所说的手机有 16g, 32g 这样的，我们用上面的这方法获得到的就是这个位置。但是手机厂商又把 SD 卡给加了回来，这篇文章讲的就是关于这个外置 SD 卡位置的读写问题。</p><a id="more"></a><hr><p>为了解决这个问题，我们使用 StorageManager 去解决，但是它里面的方法大部分是 hide 的，因此我们需要使用反射去调用。具体如何调用可以查看我的 <a href="https://github.com/zubinxiong/LifeWithAndroid/blob/master/storagedemo/src/main/java/me/ewriter/storagedemo/MainActivity.java" target="_blank" rel="noopener">Demo</a>。</p><p>通过 Demo 里面的方法，我们发现虽然我们获取到的外置 SD 卡的位置，但是我们去不能写文件啊，这不是坑爹么？实际上我们并不是严格上的不能写文件，我们只能在我们 App 的目录去写文件即 <strong>Android/data/packagename/xxx</strong>。这是因为在 4.4 之后，普通的应用就没有在外置 SD 卡根目录的写权限了。</p><p>这个方法行不通，我们要找其它的方法来解决它。我们观察下 RootExplor 这个常见的应用，它是通过让用户手动选择 SD 卡目录来实现的。查找文档后发现是 <a href="https://developer.android.com/guide/topics/providers/document-provider.html" target="_blank" rel="noopener">Storage Access FrameWork</a>) 。触发的方法是通过 <strong>OPEN_DOCUMENT_TREE</strong> 这个 intent。选择了 SD 卡之后会返回一个 intent。我们取出里面的数据查看，如下:</p><pre><code class="Java">content://com.android.externalstorage.documents/tree/C431-11E2: flg=0xc3</code></pre><p>我们发现是一个 content 开头的 uri，看起来很像是 ContentProvider 里面操作的 uri。实际上操作也是差不多的。我们把返回的 uri 作为参数，生成一个 DocumentFile 对象，通过 DocumentFile 来对 sd 卡进行操作， DocumentFile 里面封装了许多操作的方法。</p><p>这个 uri 获取到一次后记住保存下来，不然你每次操作外置 sd 卡就需要用户选择一次，体验很不好。一般来说外置sd卡的uri 都不会变，变了一般都是用户更换了sd 卡，所以在操作前不要忘记检验当前 sd 卡是否可以进行写操作。</p><hr><p><strong>参考文档</strong></p><p><a href="http://blog.desmondyao.com/2016/05/04/android-storage/" target="_blank" rel="noopener">参考文章1</a></p><p><a href="http://vjson.com/wordpress/%E8%8E%B7%E5%8F%96android%E8%AE%BE%E5%A4%87%E6%8C%82%E8%BD%BD%E7%9A%84%E6%89%80%E6%9C%89%E5%AD%98%E5%82%A8%E5%99%A8.html" target="_blank" rel="noopener">参考文章2</a></p><p><a href="https://commonsware.com/blog/2014/04/08/storage-situation-external-storage.html" target="_blank" rel="noopener">参考3</a></p><p><a href="https://developer.android.com/reference/android/support/v4/provider/DocumentFile.html" target="_blank" rel="noopener">DocumentFile 文档</a></p><p><a href="http://stackoverflow.com/questions/26744842/how-to-use-the-new-sd-card-access-api-presented-for-lollipop" target="_blank" rel="noopener">DocumentFile QA</a></p><p><a href="https://github.com/zubinxiong/LifeWithAndroid/blob/master/storagedemo/src/main/java/me/ewriter/storagedemo/MainActivity.java" target="_blank" rel="noopener">Demo 地址</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 开发艺术探索2</title>
    <link href="/2016/07/11/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A22/"/>
    <url>/2016/07/11/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A22/</url>
    
    <content type="html"><![CDATA[<h3 id="IPC-机制"><a href="#IPC-机制" class="headerlink" title="IPC 机制"></a>IPC 机制</h3><p>2.1 Android IPC 简介</p><ul><li>IPC 是 Inter-Process Communication 的缩写，含义为进程间通信或者跨进程通信，是指两个进程之间进行数据交换的过程。</li><li>IPC 不是 Android 中所独有的，任何一个操作系统都需要有相应的IPC 机制，比如Windows 上可以通过剪贴板，管道和邮槽进行进程间通信，Linux 可以通过命名管道，共享内容，信号等来进行进程间通信。不同的操作系统有不同的方式实现。Android，它的进程间通信方式不能完全继承自Linux，在Android中最有特色的进程间通信方式就是<strong>Binder</strong>，除此之外Android上还支持Socket，通过Socket 也可以实现任意两个终端之间的通信，当然同一个设备上的<strong>两个进程通过Socket 通信</strong>自然也是可以的。</li></ul><a id="more"></a><hr><p>2.2 Android 中的多进程模式</p><p>2.2.1 开启多进程模式</p><ul><li>在Android中使用多进程只有一种方法，那就是给四大组件（Activity，Service，Receiver，ContentProvider） 在AndroidMenifest 中指定<strong>android:process</strong> 属性。其实还有另一种<strong>非常规手段</strong>，通过JNI 在 native 层去fork 一个新的进程。</li></ul><pre><code class="xml">// 默认包名是me.ewriterandroid:process=&quot;me.ewriter.test&quot;android:process=&quot;:test&quot;</code></pre><ul><li><p>上面的代码中，有两种形式。带上<strong>:</strong> 的表示进程属于当前应用的私有进程，其他应用组件不可以和它跑在同一个进程。而进程名不以<strong>：</strong>开头的进程属于全局进程，其他应用通过ShareUID 的方式可以和它跑在同一个进程。上面的例子，我们的默认包名是me.ewriter。那么默认就会有<strong>me.ewriter</strong>，<strong>me.ewriter.test</strong>，<strong>me.ewriter:test</strong>三个进程</p></li><li><p>Android系统会为每一个应用分配唯一的UID，<strong>具有相同UID的应用才能共享数据</strong>。这里需要说明，两个应用通过ShareUID 跑在同一个进程中是有要求的，需要这两个应用有相同的ShareUID 并且签名相同才可以。在这种情况下，它们可以互相访问对方的私有数据，比如data目录等</p></li></ul><p>2.2.2 多进程模式的运行机制</p><ul><li>Android 为每个应用分配了一个独立的虚拟机，或者说为每个进程都分配了一个独立虚拟机，不同的虚拟机在内存分配上有不同的地址空间，这就导致了不同的虚拟机中访问同一个类的对象会产生多分副本。在书上的例子中就是me.ewriter.art_chapter2 和 me.ewriter.art_chapter2:remote 中都存在一个UserManager 类，并且这两个类是互不干扰的。</li></ul><p><img src="http://7xjkin.com1.z0.glb.clouddn.com/7.11.1.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>所有运行在不同进程的四大组件，只要它们之间需要通过内存共享数据，都会共享失败。这也是多进程所带来的主要影响。一般会造成下面几个方面的问题</p><ul><li>静态成员和单例模式完全失效</li><li>线程同步机制完全失效</li><li>SharePreferences 的可靠性下降</li><li>Application 会多次创建</li></ul></li><li><p>第一个问题例子中已经说明；第二个问题类似，由于不是一块内存了，那么不管是锁对象还是锁全局类都无法保证线程同步；第三个问题是因为SharePreference 不支持两个进程同时去执行写操作，否则会导致一定几率的数据丢失，这是因为SharePrefences 底层是通过读写xml 文件来实现的；第四个问题当一个组件跑在一个新的进程中事，由于系统在创建新的进程的同时分配独立的虚拟机，所以这个过程其实就是启动一个应用的过程。</p></li></ul><hr><p>2.3 IPC 基础概念介绍</p><ul><li>Serializable 和 Parcelable 接口可以完成对象的序列化过程，当我们需要通过Intent 和 Binder 传输数据时就需要使用Parcelable 或者Serializable。</li></ul><p>2.3.1 Serializable 接口</p><ul><li>Serializable 是Java 所提供的一个序列化接口，它是一个空接口，为对象提供标准的序列化和反序列化操作。想让一个对象实现序列化只要让这个类实现Serializable 接口并声明serialVersionUID即可，实际上serialVersionUID也不是必须的，但是这会影响到反序列化。AS 中需要做下面设置</li></ul><p><img src="http://7xjkin.com1.z0.glb.clouddn.com/7.11.2.jpg" srcset="/img/loading.gif" alt=""></p><ul><li>如何对对象序列化也很简单，参考下面的代码</li></ul><pre><code class="Java">// 序列化过程User user = new User(0 ， “jake&quot;, true);ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(”cache.txt&quot;));out.writeObject(user);out.close();// 反序列化过程ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;cache.txt&quot;));User newUser = (User) in.readObject();in.close();</code></pre><ul><li><p>序列化的时候系统会把当前类的serialVersionUID 写入序列化文件中（也可能是其他媒介），当反序列化的时候系统回去检查文件中的 serialVersionUID ，看它是否和当前类的 serialVersionUID 是否一致。如果相同则可以反序列化，如果不同则说明当前类和序列化的类相比发生了某些变化，<strong>比如成员变量的数量，类型可能发生了变化</strong> ，这个时候是无法正常反序列化的。</p></li><li><p><strong>静态成员变量属于类，不属于对象，所以不会参与序列化过程</strong>；其次<strong>transient</strong>关键字标记的成员变量不参与序列化过程。</p></li></ul><p>2.3.2 Parcelable 接口</p><p>下面是一个实现Parceable 的实例</p><pre><code class="Java">  protected User(Parcel in) {        userId = in.readInt();        userName = in.readString();        isMale = in.readByte() != 0;        book = in.readParcelable(Thread.currentThread().getContextClassLoader());    }    public static final Creator&lt;User&gt; CREATOR = new Creator&lt;User&gt;() {        @Override        public User createFromParcel(Parcel in) {            return new User(in);        }        @Override        public User[] newArray(int size) {            return new User[size];        }    };    @Override    public int describeContents() {        return 0;    }    @Override    public void writeToParcel(Parcel dest, int flags) {        dest.writeInt(userId);        dest.writeString(userName);        dest.writeByte((byte) (isMale ? 1 : 0));        dest.writeParcelable(book, 0);    }</code></pre><ul><li><p>先介绍下<strong>Parcel</strong>，Parcel内部包装了可序列话的数据，可以在Binder 中传输。序列化功能由<strong>writeToParcel</strong> 方法来完成，最终是通过Parcel 中的一系列write方法来完成的；反序列化由<strong>CRATOR</strong> 来完成，其内部表明了如何创建序列化对象和数组，并通过Parcel 的一系列read方法来完成反序列化过程；describeContents 方法表示内容描述，几乎所有情况都返回0，仅当当前对象中存在文件描述时返回1；</p></li><li><p>注意在User(Parcel in) 方法中，由于book 是另一个可序列化对象，所以它的反序列化需要传递当前线程的上下文加载器，否则会找不到类，详细的方法说明见下表：</p></li></ul><table><thead><tr><th>方法</th><th>功能</th><th>标记位</th></tr></thead><tbody><tr><td>createFromParcel(Parcel in)</td><td>从序列化后的对象中创建原始对象</td><td></td></tr><tr><td>newArray(int size)</td><td>创建指定长度的原始对象数组</td><td></td></tr><tr><td>User(Parcel in)</td><td>从序列化后的对象中创建原始对象</td><td></td></tr><tr><td>writeToParcel(Parcel dest, int flags)</td><td>将当前对象写入序列化结构中，其中flags 标识有两种值：0或者1。为1时标识当前对象需要作为返回值返回，不能立即释放资源，自护所有情况都为0</td><td>PARCELABLE_WRITE_RETURN_VALUE</td></tr><tr><td>describeContents</td><td>返回当前对象的内容描述，如果含有文件描述符，返回1，否则返回0，几乎所有情况都返回0</td><td>CONTENTS_FILE_DESCRIPTOR</td></tr></tbody></table><ul><li>像Intent， Bundle，Bitmap 等都是系统实现了Parcelable 接口的类。Serializable 是Java 的序列化接口，序列化和反序列化需要大量的I/O操作。Parcelable 主要用在内存序列化上。</li></ul><p>2.3.3 Binder</p><ul><li><p>Binder比较复杂，本节的侧重点是介绍Binder的使用以及上层原理：直观来说，<strong>Binder 是 Android 中的一个类，它实现了IBinder 接口</strong>；从IPC 角度来看，Binder 是 Android 中的一种跨进程通信方式，Binder 还可以理解为一种虚拟的物理设备，它的驱动是/dev/binder， 该通信方式在Linux 中没有；从Android Framework 角度来说，Binder 是 ServiceManager 连接各种 Manager（ActivityManager， WindowManager 等等） 和相应ManagerService 的桥梁；从Android 应用层看，Binder 是客户端和服务器端进行通信的媒介，当bindService 的时候，服务端会返回一个包含业务端调用的Binder 对象。通过这个Binder 对象，客户端就可以获取服务端提供的数据或服务，这里的服务包括普通服务和基于AIDL 的服务。</p></li><li><p>Android 开发中，Binder 主要用在Service 中，包括AIDL 和 Message ，其中普通Service 中的Binder 不涉及进程间通信，比较简单，无法触及Binder 的核心。而Messenger 的底层其实是AIDL ，所以这里选择用AIDL 来分析Binder 的工作机制</p></li><li><p>根据书中的例子创建了Book 及 IBookManager 的aidl 文件后，rebuild，如果创建正确，那么会在build 下面生成IBookManager.java 的文件，我们把它拷贝出来（附件中），看下里面的代码。</p></li><li><p>可以看到它<strong>继承了android.os.IInterface</strong>，同时它<strong>自己也还是一个接口</strong>，所有可以在Binder 中传输的接口都需要集成IInterface 接口。看下类中，它申明了两个方法，getBookList 和 addBook，这是我们在aidl文件中声明的方法，同时它还<strong>申明了两个整形id标识</strong>这两个方法，这两个id标识在transcat 过程中客户端所请求的到底是哪个方法。接着声明了一个<strong>内部类Stub</strong>。这个<strong>Stub 就是一个Binder 类（extends android.os.IInterface）</strong>，当客户端和服务端都位于同一个进程时，方法调用不会走跨进程transact 过程。当处于不同进程，方法调用走transact 过程，这个过程由<strong>Stub 的内部代理类Proxy 完成</strong>。 这个接口的*<em>核心实现就是它的内部类Stub 和 Stub 的内部代理类Proxy *</em>；</p></li><li><p>关于Stub 和 Proxy 中的方法可以看附件中文件的注释</p></li><li><p>DESCRIPTOR: Binder 的唯一标识，一般用当前Binder 的类名表示</p></li><li><p>asInterface(android.os.IBinder obj) ：用于<strong>将服务端的Binder 对象转换成客户端所需要的AIDL 接口类型</strong>的对象，这种转换过程是<strong>区分进程</strong>的，如果客户端和服务端位于同一进程，那么此方法返回的就是服务端的Stub对象本身，否则返回的是系统封装后的Stub.proxy 对象</p></li><li><p>asBinder() ： 返回当前Binder 对象</p></li><li><p>onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags)</p><ul><li>这个方法<strong>运行在服务端的Binder 线程池</strong>中，当客户发起跨进程请求时，远程请求会通过系统底层封装后交由此方法处理。 1.服务端通过code 确定客户端请求的目标方法是什么，接着从data 中取出目标方法所需要的 参数，然后执行目标方法 2.当目标方法执行完后，就像reply中写入返回值(如果存在)。如果返回false，那么客户端的请求会失败，我们可以用这个特性做权限验证，避免任何一个 进程调用我们的服务</li></ul></li><li><p>Proxy#[方法]： <strong>代理类中的接口方法，这些方法运行在客户端</strong>。当客户端远程调用此方法时，它的内部实现是：首先创建该方法所需要的参数，然后把方法的参数信息写入到_data中，接着调用transact方法来发起RPC请求，同时当前线程挂起；然后服务端的onTransact方法会被调用，直到RPC过程返回后，当前线程继续执行，并从_reply中取出RPC过程的返回结果，最后返回_reply中的数据。</p></li></ul><p>通过上面的分析，大致了解了 Binder 的工作机制，但还是有两点需要额外说明一下：当客户端发起远程请求时，由于当前线程会被挂起直至服务端进程返回数据，因此如果一个远程方法很耗时的话是不能放在 UI 线程中请求的；其次，由于服务端的 Binder 方法运行在 Binder 的线程池中，所以 Binder 方法不管是否耗时都应该采用同步的方式去实现，因为它已经运行在一个线程中了。下面这个图说明了 Binder 的工作机制</p><p><img src="http://7xjkin.com1.z0.glb.clouddn.com/7.11.3.jpg" srcset="/img/loading.gif" alt=""></p><ul><li><p>从上面的分析来看，我们完全可以不提供AIDL 文件 即可实现Binder ，之所以提供AIDL 文件，是为了方便系统帮我们生成代码。系统生成的那个类主要由两部分组成，它本身是Binder 的接口（继承IInterface），其次它的内部有一个Stub 类，继承自Binder。</p></li><li><p>Binder 的两个很重要的方法 <strong>linkToDeath</strong>  和 <strong>unLinkToDeath</strong>。Binder 运行在服务端进程，如果服务端进程由于某种原因异常终止，这时我们到服务端的Binder断裂（称为Binder 死亡），会导致我们的调用失败。</p></li></ul><pre><code class="Java">private IBinder.DeathRecipient mDeathRecipient = new IBinder.DeathRecipient() {    @Override    public void binderDied() {        Log.d(TAG, &quot;binder died. tname:&quot; + Thread.currentThread().getName());        if (mRemoteBookManager == null)           return;        mRemoteBookManager.asBinder().unlinkToDeath(mDeathRecipient, 0);        mRemoteBookManager = null;        // TODO:这里重新绑定远程Service    }};</code></pre><hr><p>2.4 Android 中的IPC 方式</p><p>2.4.1 使用Bundle</p><ul><li>Bundle 实现了 Parcelable 接口，所以方便在不同进程间传递。记住我们传输的数据必须能够被序列化</li></ul><p>2.4.2 使用文件共享</p><ul><li><p>Android 基于 Linux ，使得并发读/写可以没限制的进行，甚至两个线程同时对同一个文件进行写操作都允许，但是这可能会出现问题。</p></li><li><p>文件共享这种方式对格式没有要求，只要双方约定好即可。文件读写适合在对数据同步要求不高的进程之间进行通信，并且要妥善解决并发读/写的问题。</p></li><li><p>SharedPreferences 是一个特例，虽然是通过读写 xml 实现的，但是由于系统对它的读写有缓存策略，即在内存中会有一份 SharedPreferences 文件的缓存，因此在多进程模式下，系统对它的读写就ui变得不可靠。</p></li></ul><p>2.4.3 使用Messenger</p><ul><li><p>Messenger 可以翻译为信使，通过它可以在不同进程间传递 Message 对象，Message 中放入我们需要传递的数据即可。Messenger 是一种轻量级的 IPC 方案，它的底层是 AIDL. 下面是 Messenger 的两个构造方法，不管是 IMessenger 还是 Stub.asInterface ，都能表明它的底层是 AIDL.</p></li><li><p>Messenger 是串行处理请求而的，即它一次处理一个请求，因此我们在服务端不用考虑线程同步的问题，这是因为服务端不存在并发执行的情况。</p></li></ul><pre><code class="Java">public Messenger(Handler target) {    mTarget = target.getIMessenger();}public Messenger(IBinder target) {    mTarget = IMessenger.Stub.asInterface(target);}</code></pre><p>实现一个 Messenger 有如下几个步骤，分为服务端和客户端</p><ul><li><p>服务端进程： 在服务端创建一个 Service 来处理客户端的链接请求，同时创建一个 Handler 并通过它来创建一个 Messenger 对象，然后在 Service 的 onBind 中返回这个 Messenger 对象底层的 Binder 即可。</p></li><li><p>客户端进程：首先要绑定服务端的 Service，绑定成功后用服务端返回的 IBinder 对象创建一个 Messenger， 通过这个 Messenger 就可以像服务端发送消息了，发消息的类型为 Message 对象。如果需要<strong>服务端能回应客户端</strong>，那就和服务端一样创建一个 Handler 并创建一个新的 Messenger，<strong>并把这个 Messenger 对象通过 replyTo 参数 传递给服务端</strong>，服务端通过这个 replyTo 参数就可以回应客户端。</p></li></ul><p><img src="http://7xjkin.com1.z0.glb.clouddn.com/7.11.4.jpg" srcset="/img/loading.gif" alt=""></p><p>2.4.4 使用AIDL</p><ul><li>Messenger 以串行处理进程间通信，所以在面对大量并发请求并不是很合适。同时 <strong>Messenger 的作用主要是传递消息</strong>， 很多时候我们要跨进程调用服务端的方法，这种情形 Messenger 就做不到，但是可以用 AIDL，Messenger 本质上也是 AIDL， 只是做了封装方便调用而已。</li></ul><p>实现 AIDL 来进行进程间通信，分为客户端和服务端两个方面</p><ul><li>服务端： 创建一个 Service 用来监听客户端的情趣，然后创建一个 AIDL 文件，将暴露给客户端的请求都在 AIDL 文件中声明，最后实现这个 AIDL 接口即可</li><li>客户端：绑定服务端 Service，绑定成功后，将服务端返回的 Binder 对象转换成 AIDL 接口所属类型就可以调用 AIDL 中的方法了</li><li>创建 AIDL 文件： 并不是所有数据类型都可以使用的，AIDL 支持下面这些数据类型<ul><li>基本数据类型(int， long，char，boolean，double 等)</li><li>String 和 CharSequence</li><li>List： 只支持 ArrayList ，里面每个元素都必须能够被 AIDL 支持</li><li>Map： 只支持 HashMap，里面每个 key , value 都必须被 AIDL 支持</li><li>Parcelabe</li><li>AIDL: 所有的 AIDL 接口本身也可以在 AIDL 文件中使用。</li><li>AIDL 中除了基本数据类型，其他类型的参数必须表上方向： in，out 或者 inout，in 表示输入型参数，out 表示输出型参数，inout 表示输入输出型参数。不能一概的使用 out 或者 inout，因为这在底层实现是有开销的。<strong>AIDL 接口中只支持方法，不支持声明静态常量</strong></li></ul></li><li>远程服务端 Service 的实现 ：参考 Demo 中的 <a href="https://github.com/zubinxiong/LifeWithAndroid/blob/master/art_chapter2/src/main/java/me/ewriter/art_chapter2/aidl/BookManagerService.java" target="_blank" rel="noopener">BookManagerService</a></li><li>客户端的实现：参考 Demo 中的 <a href="https://github.com/zubinxiong/LifeWithAndroid/blob/master/art_chapter2/src/main/java/me/ewriter/art_chapter2/aidl/BookManagerActivity.java" target="_blank" rel="noopener">BookManagerActivity</a></li></ul><p>远程服务端和客户端的实现，建议结合上面的源码一起看。里面增加了关于 CopyOnWriteArrayList 和 RemoteCallbackList 相关的注释</p><p>默认情况下，我们的远程服务任何人都可以连接，因此我们必须给服务加入权限验证功能。这里介绍两种常用的方法：</p><ul><li>第一种方法在 onBind 中验证，不同步就直接返回 null。验证的方法很多，比如使用 permission 验证。首先现在 AndroidManifest 中声明所需的权限，让后在 onBind 中做权限处理。如果自己内部的应用想要绑定我们的服务，只需要在它的 AndroidManifest 文件中使用 permission 即可</li><li><pre><code class="xml">&lt;permission      android:name=&quot;com.ryg.chapter_2.permission.ACCESS_BOOK_SERVICE&quot;      android:protectionLevel=&quot;normal&quot; /&gt;&lt;use-permission android:name=“com.ryg.chapter_2.permission.ACCESS_BOOK_SERVICE” /&gt;</code></pre></li></ul><pre><code class="Java">int check = checkCallingOrSelfPermission(&quot;com.ryg.chapter_2.permission.ACCESS_BOOK_SERVICE&quot;);if (check == PackageManager.PERMISSION_DENIED) {     return null;}</code></pre><ul><li><p>第二种方法在服务端的 onTransact 方法中进行权限验证，失败就返回 false。除了使用 permission 验证，还可以采用 Uid 和 Pid 来验证，通过 getCallingUid 和 getCallingPid 可以拿到客户端所属应用的 Uid 和Pid，通过这两个参数可以做一些验证，比如验证包名。</p></li><li><pre><code class="Java、">@Overridepublic boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {  int check = checkCallingOrSelfPermission(&quot;com.ryg.chapter_2.permission.ACCESS_BOOK_SERVICE&quot;);  Log.d(TAG, &quot;check=&quot; + check);  if (check == PackageManager.PERMISSION_DENIED) {      return false;  }  String packageName = null;  String[] packages = getPackageManager().getPackagesForUid(getCallingUid());  if (packages != null &amp;&amp; packages.length &gt; 0) {      packageName = packages[0];  }  Log.d(TAG, &quot;onTransact: &quot; + packageName);  if (!packageName.startsWith(&quot;com.ryg&quot;)) {      return false;  }  return super.onTransact(code, data, reply, flags);}</code></pre></li></ul><p>2.4.5 使用ContentProvider</p><ul><li><p>ContentProvider 是 Android 中提供的专门用于处理不同应用见进行数据共享的方式。和 Messenger 一样，*<em>ContentProvider 的底层实现也是 Binder *</em>。实现的时候除了 CRUD 操作还有防止 SQL 注入和权限控制等。</p></li><li><p>实现 ContentProvider 只要继承 ContentProvider 并实现 onCreate、query、update、insert、delete 和 getType 这六个方法。getType 用来返回 Uri 请求对应的 MIME 类型，不关心这个选项的话只要返回 null 或者 <em>/</em> 即可。<strong>根据 Binder 的原理，这六个方法均运行在 ContentProvider 的进程中，除了 onCreate 由系统回调并运行在主线程里，其他五个方法均有外界回调并运行在 Binder 线程池中。</strong></p></li><li><p>注册 ContentProvider， 其中 android:authorities 是唯一标识，通过这个属性外部应用可以访问我们的 BookProvider，因此必须是唯一的，可以在命名的时候加上我们的包名。如果想要限制外界程序访问可以加上 android:permission 属性，也可以细分为读权限和写权限，分别对应 android:readPermission 和 android:writePermission 属性。</p></li><li><p>ContentProvider 通过 Uri 来区分外界要访问的数据集合，为了知道外界访问什么表，需要单独为它们定义 Uri 和 Uri_Code 。我们可以用 UriMatcher 的 addURI 方法将 Uri 和 Uri_Code 相关联。</p></li><li><p>query、update、insert、delete 四大方法是存在多线程并发访问的，所以方法内部要做好线程同步</p></li></ul><p>2.4.6 使用Socket</p><p>Socket 分为流式套接字和用户数据报套接字两种，分别对应于网络传输控制层中的 TCP 和 UDP 协议。使用 Socket 进行同行，需要声名下面的权限：</p><pre><code class="xml">    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt;</code></pre><p>具体实现可以查看 <a href="https://github.com/zubinxiong/LifeWithAndroid/tree/master/art_chapter2" target="_blank" rel="noopener">Demo</a></p><hr><p>2.5 Binder 连接池</p><p>项目大了之后，可能 AIDL 会有很多，这时候如果新建很多 Service 会让应用看起来很中。因此我们要将所有的 AIDL 放在同一个 Service 中去管理。</p><p>Binder 连接池的主要作用是将每个业务模块的 Binder 请求统一转发到远程 Service 中去执行，从而避免了重复创建 Service 的过程</p><p><img src="http://7xjkin.com1.z0.glb.clouddn.com/7.11.5.jpg" srcset="/img/loading.gif" alt=""></p><p>为了模拟，我们提供了两个 AIDL 接口（ISecurityCenter 和 ICompute）来模拟上面提到的多个业务模块都要使用 AIDL 的情况，其中 ISecurityCenter 接口提供加密解密功能，具体可以查看 <a href="https://github.com/zubinxiong/LifeWithAndroid/blob/master/art_chapter2/src/main/java/me/ewriter/art_chapter2/binderpool/BinderPoolActivity.java" target="_blank" rel="noopener">BinderPoolActivity</a></p><hr><p>2.6 选择合适的 IPC 方式</p><table><thead><tr><th>名称</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>Bundle</td><td>简单易用</td><td>只能传输Bundle 支持的数据类型</td><td>四大组件间的进程通信</td></tr><tr><td>文件共享</td><td>简单易用</td><td>不适合高并发场景，并且无法做到进程间的既是通信</td><td>无并发访问的情形，交换简单的数据实用性不高的场景</td></tr><tr><td>AIDL</td><td>功能强大，支持一对多并发通信，支持实时通信</td><td>使用稍复杂，需要处理好线程同步</td><td>一对多通信且有 RPC 需求</td></tr><tr><td>Messenger</td><td>功能一般，支持一对多串行通信，支持实时通信</td><td>不能很好处理高并发情形，不支持 RPC，数据通过 Message 进行传输，因此只能传输 Bundle 支持的数据类型</td><td>低并发的一对多即时通信，无 RPC 需求，或者无须返回结果的 RPC 需求</td></tr><tr><td>ContentProvider</td><td>在数据源访问方面功能强大，支持一对多并发数据共享，可通过 Call 方法扩展其他操作</td><td>可以理解为受约束的 AIDL，主要提供数据源的 CRUD 操作</td><td>一对多的进程间的数据共享</td></tr><tr><td>Socket</td><td>功能强大，可以通过网络传输字节流，支持一对多并发实时通信</td><td>实现细节稍微有点麻烦，不支持直接的 RPC</td><td>网络数据交换</td></tr></tbody></table><hr><p><a href="https://github.com/zubinxiong/LifeWithAndroid/tree/master/art_chapter2" target="_blank" rel="noopener">Demo 地址</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 开发艺术探索1</title>
    <link href="/2016/07/04/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A21/"/>
    <url>/2016/07/04/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A21/</url>
    
    <content type="html"><![CDATA[<h3 id="Activity-的生命周期和启动模式"><a href="#Activity-的生命周期和启动模式" class="headerlink" title="Activity 的生命周期和启动模式"></a>Activity 的生命周期和启动模式</h3><p>1.1 Activity 的生命周期全面分析</p><p>Activity 的生命周期分为两部分内容，一部分是典型情况下的生命周期，另一部分是异常情况下的生命周期。<strong>典型情况指的是在有用户参与的情况下， Activity 所经过的声明周期的改变；异常情况指 Activity 被系统回收或者由于当前设备的 Configuration 发生改变从而导致 Activity 被销毁重建</strong></p><a id="more"></a><p>1.1.1 典型情况下的声明周期分析</p><ul><li>onCreate ：表示 Activity 正在被创建，生命周期的第一个方法。做一些初始化工作，比如 setContentView，初始化 Activity 所需数据等。</li><li>onRestart：表示 Activity 正在重新启动。一般当前 Activity 从不可见重新变成可见状态， onRestart 就会被调用。</li><li>onStart：表示 Activity 正在被启动，即将开始，这时候 Activity 已经可见了 ，但是还没有出现在前台，无法与用户交互</li><li>onResume：表示 Activity 已经可见了，并且出现在前台开始活动。和 onStart 的区别是一个在前台，一个在后台。两者都是 Activity 可见。</li><li>onPause：表示 Activity 正在停止，正常情况下，紧接着 onStop 就会被调用。特殊情况下，如果快速返回当前 Activity， 那么 onResume 会被调用。此时可以做一些存储数据，停止动画等工作，但不能太耗时，因为会影响到 Activity 的显示，onPause 必须先执行完，新 Activity 的 onResume 才会执行。</li><li>onStop：表示 Activity 即将停止，可以做一些重量级的回收工作，同样不能太耗时</li><li>onDestory：表示 Activity 即将被销毁，这是 Activity 声明周期的最后一个回调，可以做些回收工作和最终的资源释放。<br><img src="http://7xjkin.com1.z0.glb.clouddn.com/7.4.1.png" srcset="/img/loading.gif" alt=""></li></ul><p>1.1.2 异常情况下的生命周期分析</p><ul><li>资源相关的系统配置发生改变导致 Activity 被杀死重新创建</li></ul><p>例如我们旋转屏幕后，因为图片分为普通和横屏两种，默认情况下， Activity 就会被销毁并重新创建，当然我们也可以阻止系统重建我们的 Activity。默认情况下，我们不需要做特殊处理，当系统配置发生变化后， Activity 就会被销毁并重新创建。生命周期如下图所示：<br><img src="http://7xjkin.com1.z0.glb.clouddn.com/7.4.2.jpg" srcset="/img/loading.gif" alt=""><br><strong>onSaveInstanceState 调用时机在 onStop 之前，它和 onPause 没有既定的时序关系。</strong> 销毁后会把所保存的 Bundle 对象作为参数传递给 onRestoreInstanceState 和 onCreate 方法，我们可以在这两个方法里判断是否重建，<strong>onRestoreInstanceState 的调用时机在 onStart 之后</strong></p><ul><li><p>资源内存不足导致低优先级 Activity 被杀死</p><ul><li><p>Activity 按照优先级从高到低，可以分为如下三种：</p></li><li><p>前台 Activity：正在和用户交互的 Activity，优先级最高</p></li><li><p>可见但非前台 Activity：比如 Activity 中弹出了一个对话框，导致 Activity 可见但是位于后台无法和用户直接交互</p></li><li><p>后台 Activity：已经被暂停的 Activity，比如执行了 onStop，优先级最低。</p><p>系统配置中有很多内容，当某项内容发生改变后，我们不想系统重新创建 Activity， 可以指定 configChanges 属性。指定多个值可以用 ”|“ 连接起来。比如不想 Activity 旋转时重建，可以使用下面的代码，具体的 configChanges 项目和含义见下表：</p></li></ul></li></ul><pre><code class="xml">android:configChanges=&quot;orientation&quot;</code></pre><p><img src="http://7xjkin.com1.z0.glb.clouddn.com/7.4.3.jpg" srcset="/img/loading.gif" alt=""><br>我们常用的只有 locale、orientation 和 keyboardHidden 这三个选项，其它很少使用。screenSize 和 smallestScreenSize 这两个参数只和编译选项有关和运行环境无关</p><hr><p>1.2 Activity 的启动模式</p><p>1.2.1 Activity 的 LaunchMode</p><ul><li>standard：标准模式。standard 模式的 Activity 默认会进入启动它的 Activity 所属的任务栈中。所以如果用 ApplicationContext 会报错，解决方法是为待启动的 Activity 指定 FLAG_ACTIVITY_NEW_TASK 标记位.</li><li>singleTop：栈顶复用模式。</li><li>singleTask：栈内复用模式。这是一种<strong>单实例模式</strong>，在这种模式下，只要 Activity 在一个栈中存在，那么多次启动此 Activity 都不会重新创建实例。<strong>和 singleTop 一样，系统也会回调 onNewIntent 。</strong></li><li>singleInstance：单实例模式。这是种加强的 singleTask 模式，它除了具有 singleTask 模式的所有特性外，加强了一点，<strong>那就是具有此模式的 Activity 只能单独的位于一个任务栈中，由于栈内服用的特性，后续的请求都不会创建新的 Activity，除非这个独特的任务栈被系统销毁</strong></li></ul><p><strong>TaskAffinity</strong> 这个参数标识了一个 Activity 所需要的任务栈的名字，默认情况下，所有 Activity 所需的任务栈的名字为应用的包名，也可以自行定义，但是不能和包名相同。<strong>TaskAffinity属性主要和singleTask启动模式或者allowTaskReparenting属性配对使用，在其他情况下没有意义</strong></p><p>任务栈分前台任务栈和后台任务栈，后台任务栈中的 Activity 位于暂停状态，用户可以通过切换将后台任务栈再次调到前台</p><p>当 TaskAffinity 和 singleTask 启动模式配对使用的时候，它是具有该模式的 Activity 的目前任务栈的名字，待启动的 Activity 会运行在名字和 TaskAffinity 相同的任务栈中；<br>当 TaskAffinity 和 allowTaskReparenting 结合的时候，当一个应用A启动了应用B的某个 Activity C 后，如果 Activity C 的 allowTaskReparenting 属性设置为 true 的话，那么当应用B被启动后，系统会发现 Activity C 所需的任务栈存在了，就将 Activity C 从A的任务栈中转移到B的任务栈中。</p><p>设置方式有两种，一个是在 AndroidManifest 中设置或者在 Intent 中设置 flags</p><p>1.2.2 Activity 的 Flags</p><p>介绍几个常用的</p><ul><li>FLAG_ACTIVITY_NEW_TASK ： 和 singleTask 启动模式相同</li><li>FLAG_ACTIVITY_SINGLE_TOP ： 和 singleTop 启动模式相同</li><li>FLAG_ACTIVITY_CLEAR_TOP ： 启动时，在同一个任务栈中所有位于它上面的 Activity 都要出栈。这个模式一般需要和 FLAG_ACTIVITY_NEW_TASK 配合使用</li><li>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS： 具有这个标记的 Activity 不会出现在历史列表中。它等同于在 XML 中指定 Activity 的属性 android:excludeFromRecents=”true”</li></ul><hr><p>1.3 IntentFilter 匹配规则</p><pre><code class="xml">&lt;intent-filter&gt;    &lt;action android:name=&quot;com.ryg.charpter_1.c&quot; /&gt;    &lt;action android:name=&quot;com.ryg.charpter_1.d&quot; /&gt;    &lt;category android:name=&quot;com.ryg.category.c&quot; /&gt;    &lt;category android:name=&quot;com.ryg.category.d&quot; /&gt;    &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;    &lt;data android:mimeType=&quot;text/plain&quot; /&gt;&lt;/intent-filter&gt;</code></pre><p>IntentFilter 中的过滤信息有 action、category、data。一个过滤列表中的 action、category 和 data 可以有多个。只有一个 Intent 同时匹配 action 类别、category 类别、data 类别才算完全匹配，只有完全匹配才能完全启动目标 Activity。一个 Activity 可以有多个 intent-filter，一个 Intent 只要能匹配任何一组 intent-filter 即可以成功启动对应的 Activity</p><ul><li>action 的匹配规则: action 是一个字符串，系统定义了一些 action，同时我们也可以在应用中自定义自己的 action。action 的匹配要求 Intent 中的 action <strong>存在且必须和过滤规则中的其中一个 action 相同</strong>，<strong>区分大小写</strong>。</li><li>category 的匹配规则: category 是一个字符串，系统预定义了一些 category，我们也可以在应用中定义自己的 category。<strong>Intent 中可以没有 category，但如果一旦有 category，不管有几个，每个都要能够和过滤规则中的任何一个 category 相同</strong>。</li><li>data 的匹配规则: data 由两部分组成，mimeType 和 URI。mimeType 指媒体类型，比如 image/jpeg、audio/mpeg4-generic 和 video/* 等，可以表示图片，文本，视频等不同的媒体格式，而 URI 中包含的数据就比较多，下面是 URI 的结构</li></ul><pre><code class="xml">&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;]content://com.example.project:200/folder/subfolder/etchttp://www.baidu.com:80/search/info</code></pre><p>如果要为Intent指定完整的data，必须要调用setDataAndType方法。<strong>不能先调用setData然后调用setType，因为这两个方法会彼此清除对方的值</strong>。</p><p>判断是否有 Activity 能匹配我们的隐式 Intent:</p><ul><li>采用 PackageManager 的 resolveActivity方法</li><li>Intent 的 resolveActivity 方法</li></ul><hr><p><a href="https://github.com/zubinxiong/LifeWithAndroid/tree/master/art_chapter1" target="_blank" rel="noopener">Demo 地址</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 异步消息处理解析</title>
    <link href="/2016/06/13/Handler-Messager-Looper%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2016/06/13/Handler-Messager-Looper%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>Handler 是 Android 上常用的异步消息处理机制，实际上 Handler 只是一个表象，背后的Looper , MessageQueue 才是重点，只是我们在使用的时候系统把这些给隐藏了，我们通常察觉不到而已。这次的源码解析是以support－v7-23.2.1 里面的为准，可能会与之前的源码或者之后的有些不同，但相信大体上是不会有很大变化的，可以参考我在代码上的注释一起看。具体看<a href="https://github.com/zubinxiong/BlogDemo/tree/master/source/handler" target="_blank" rel="noopener">这里</a></p><a id="more"></a><ul><li>Handler 的创建</li></ul><p>Handler 如何用，我想大家应该都比较熟悉，就是new 一个Handler 对象，新建一个message 对象。然后通过sendMessage 或者 sendMessageDelyed 这样的方法发出消息，然后在回调handleMessage 中处理我们的消息，整个基本的过程就是这样的。但是我们仅仅会用是不行的，接下来我们去源码看下整个工作流程是怎么样的。</p><ul><li>工作流程<ul><li>创建Handler </li><li>我们新建了一个Handler ,在构造函数里面有一段mLooper.myLooper()的方法返回了一个Looper对象并赋值给mLooper ,如果mLooper 为空，就抛出异常，handler 不能在looper.prepare()方法前新建。</li><li>looper.myLooper() 里面是从ThreadLocal中取出来的，而ThreadLocal 又是在looper.prepare() 里面用set方法赋值的，所以初始化是在prepare里面的。同时在Looper 的构造函数新建了一个MessageQueue对象并赋值给handler中，同时获取了当前Thread,并将Looper与当前Thread相绑定。</li><li>发送消息</li><li>我们发送消息通常都是用sendmessage 的，跟着这个方法进入发现最后都跑到了sendMessageAtTime（Message msg, long uptimeMillis）这个方法里面.我们在这里面可以看到新建了一个MessageQueue,并且调用了它的enqeueMessage(msg, upTimeMillis) 方法，看名字我们大致可以猜到这个方法是把message 入队列的。</li><li>在MessageQueue里面，<strong>MessageQueue并没有使用一个集合把所有的消息都保存起来，它只使用了一个mMessages对象表示当前待处理的消息</strong>。<strong>所谓的入队其实就是将所有的消息按时间来进行排序，这个时间当然就是我们刚才介绍的uptimeMillis参数</strong>。具体的操作方法就根据时间的顺序调用msg.next，从而为每一个消息指定它的下一个消息是什么。</li><li>现在入队操作我们就已经看明白了，那出队操作是在哪里进行的呢?这个就需要看一看Looper.loop()方法的源码。Looper.loop() 方法将Message 从MessageQueue 出栈。大致方法就是在这个方法里面不断调用 MessageQueue.next 方法，找下一个Message 直到Message 为空。</li><li>每次有Message出队列的时候就调用dispatchmessage 方法（Handler 中）。dispatchmessage方法又回把时间传递给handler 中的handlemessage方法处理。这样循环往复就完成了操作</li></ul></li></ul><hr><p>上面的东西讲的比较乱，但是大致的内容都讲到了。提炼一下观点</p><ul><li>Looper 就是循环工作的线程</li><li>一个Thread 只能有一个Looper 对象，它是一个 ThreadLocal</li><li>一个线程可以有多个handler，但是只能有一个looper</li></ul><hr><p>todo: 待补充关键源码截图，handler 消息流转图</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>更新博客主题及https</title>
    <link href="/2016/06/07/%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/"/>
    <url>/2016/06/07/%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="更新了博客的主题"><a href="#更新了博客的主题" class="headerlink" title="更新了博客的主题"></a>更新了博客的主题</h3><ul><li>修改了默认的模版，输出的时候增加下面的代码以支持 Android Chrome 39 之后的状态栏颜色变化。具体位置在hexo 主题下面，一般是layout里面的.jade 文件，这个很简单，在里面找一下就行了<a id="more"></a></li></ul><pre><code class="Html">&lt;meta name=&quot;theme-color&quot; content=&quot;#aaaaaa&quot;&gt;</code></pre><h3 id="博客新增支持了https"><a href="#博客新增支持了https" class="headerlink" title="博客新增支持了https"></a>博客新增支持了https</h3><ul><li>用的傻瓜式的<a href="http://kloudsec.com" target="_blank" rel="noopener">kloudsec</a>,基本上就是一键式的了，配置下dns就可以了。网上介绍文章很多没什么好说的，搜一下即可，有什么不明白的也可以在留言里面补充</li></ul>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 群英传读书笔记4</title>
    <link href="/2016/06/03/Android%E7%BE%A4%E8%8B%B1%E4%BC%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B04/"/>
    <url>/2016/06/03/Android%E7%BE%A4%E8%8B%B1%E4%BC%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B04/</url>
    
    <content type="html"><![CDATA[<h3 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h3><ul><li>Android 的生命周期与工作模式：下面两张图介绍了Android的生命周期</li></ul><a id="more"></a><p><img src="http://7xjkin.com1.z0.glb.clouddn.com/8.1.jpg" srcset="/img/loading.gif" alt=""><br><img src="http://7xjkin.com1.z0.glb.clouddn.com/8.2.jpg" srcset="/img/loading.gif" alt=""></p><ul><li>onSaveInstanceState  方法并不是每次Activity 离开前台都会被调用的，如果用户手动调用了finish则不会被调用。这个方法被调用的原则就是系统未经允许关闭了activity(比如内存过低等)</li></ul><hr><ul><li>Activity 调用栈管理</li></ul><p>standard ， singleTop， singleTask， singleInstance 四种启动模式</p><ul><li>standard: 标准模式，每次都会新建入栈，不管栈内是不是已经有了这个activity</li><li>singleTop: 栈顶判断</li><li>singleTask: 检测整个栈内是不是有这个activity，将在这个activity上的其他activity都出栈</li><li>singleInstance : singleInstance模式下会将打开的Activity压入一个新建的任务栈中。例如：Task栈1中结构为：A B C，C通过Intent跳转到了D（D的启动模式为singleInstance），那么则会新建一个Task 栈2，栈1中结构依旧为A B C，栈2中结构为D，此时屏幕中显示D，之后D通过Intent跳转到D，栈2中不会压入新的D，所以2个栈中的情况没发生改变。如果D跳转到了C，那么就会根据C对应的启动模式在栈1中进行对应的操作，C如果为standard，那么D跳转到C，栈1的结构为A B C C，此时点击返回按钮，还是在C，栈1的结构变为A B C，而不会回到D。<a href="http://hujiaweibujidao.github.io/blog/2015/11/28/Android-Heros-Reading-Notes-4/" target="_blank" rel="noopener">hujiaweibujidao</a></li></ul><hr><ul><li>Intent Flag 启动模式<ul><li>Intent.FLAG_ACTIVITY_NEW_TASK: 使用一个新的Task 来启动Activity，通常用在Service 中启动Activity 的场景</li><li>Intent.FLAG_ACTIVITY_SINGLE_TOP:  与android:launchMode = “singleTop” 效果相同</li><li>Intent.FLAG_ACTIVITY_CLEAR_TOP:   与singleTask 效果相同</li><li>Intent.FLAG_ACTIVITY_NO_HISTORY:  使用这种模式启动Activity，当Activity启动其他activity后，这个activity就小时了，不会保留在栈中。例如A-B,B以这种模式启动C，C在启动D。当前栈为ABD</li></ul></li></ul><hr><ul><li>清空任务栈<ul><li>clearTaskOnLaunch ，每次返回该Activity时，都将在该Activity之上把所有Activity都清除</li><li>finishOnTaskLaunch：clearTaskOnLaunch作用在别的Activity身上，而finishOnTaskLaunch作用在自己身上。通过这个属性，当离开这个Activity所在的task，那么当用户再返回时，该Activity就会被finish掉。</li><li>alwaysRetainTaskState：如果将Activity的这个属性设置为true，那么该Activity所在的task将不接受任何清理命令，一直保持当前task状态。</li></ul></li></ul><hr><h3 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h3><p>1.Android 系统信息的获取</p><ul><li>android.os.Build 主板，Android定制商，CPU指令集等等</li><li>SystemProperty OS版本，OS名称， OS 架构等等</li></ul><p>2.PackageManager 的使用</p><ul><li>ActivityInfo 封装了Mainfest 文件中的<activity/> <receiver/> 之间的所有信息，包括name，icon，label， launchmode 等</li><li>ServiceInfo 封装了<service></service> 之间的信息</li><li>ApplicationInfo 封装了Application 的信息，其中包含了很多Flag，例如flag_system 表示系统应用，flag_external_storage 表示安装在sd卡上的应用等等</li><li>PackageInfo 包含了所有activity，service 等信息</li><li>ResolveInfo 封装的是包含信息的上一级信息，所以它可以返回ActivityInfo、ServiceInfo等包含的信息，它经常用来帮助我们找到那些包含特定Intent条件的信息，如带分享功能、播放功能的应用。</li><li>PackageManager 经常使用的方法: <ul><li>getPackageManger、getApplicationInfo、getApplicationIcon、getInstalledApplications、getInstalledPackages、queryIntentActivities、queryIntentServices、resolveActivity、resolveService等</li></ul></li></ul><p>3.ActivityManager 的使用</p><ul><li>ActivityManager封装了不少对象，每个对象都保存着一些重要信息。</li><li>ActivityManager.MemoryInfo：关于系统内存的信息，例如availMem(系统可用内存)、totalMem(总内存)等；</li><li>Debug.MemoryInfo：该MemoryInfo主要用于统计进程下的内存信息；</li><li>RunningAppProceeInfo：运行进程的信息，存储的是与进程相关的信息，例如processName、pid、uid等；</li><li>RunningServiceInfo：运行服务的信息，存储的是服务进程的信息，例如activeSince(第一次被激活时间)等。</li><li>packages.xml文件(位于/data/system目录下<ul><li>在系统初始化的时候，PackageManager的底层实现类PackageManagerService会去扫描系统中的一些特定的目录，并解析其中的apk文件，最后把它获得的应用信息保存到packages.xml文件中，当系统中的应用安装、删除或者升级时，它也会被更新。</li></ul></li></ul><p>4.Android 安全机制</p><ul><li>proguard 代码混淆</li><li>AndroidMainfest 文件权限声明、权限检查机制</li><li>应用签名机制：数字证书</li><li>Linux 内核层安全机制：Uid， 访问权限控制</li><li>Android虚拟机沙箱机制： 沙箱隔离</li></ul><hr><h3 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h3><p>1.布局优化：避免嵌套过多无用布局</p><ul><li>使用layout 标签重用布局</li><li>使用ViewStub 实现View的延迟加载</li><li>ViewStub 可以用setvisibility 或者 viewstub.inflate() 两种方法处理</li><li>ViewStub 和View.Gone 初始的时候都不会显示，但是ViewStub 在初始的时候并不会去渲染，只有调用了上面的方法才开始渲染，View 在一开始的时候就开始渲染了。其他两者并没有太大的区别。</li><li>Hierarchy Viewer <ul><li>如果没有任何分支的时候说明这个View 是多余的，可以去掉。手机需要root 或者直接在模拟器上查看</li></ul></li></ul><p>2.内存优化<br>通常情况下我们所说的内存是指手机的RAM，它包括以下几部分：<br>(1)寄存器：寄存器处于CPU内部，在程序中无法控制；<br>(2)栈：存放基本数据类型和对象的引用；<br>(3)堆：存放对象和数组，有虚拟机GC来管理；<br>(4)静态存储区域(static field)：在固定的位置存放应用程序运行时一直存在的数据，Java在内存中专门划分了一个静态存储区域来管理一些特殊的数据变量，如静态的数据变量；<br>(5)常量池(constant pool)：虚拟机必须为每个被装在的类维护一个常量池，常量池就是这个类所用的常量的一个有序集合，包括直接常量（基本类型、string）和对其他类型、字段和方法的符号引用。</p><p>内存优化实例：<br>Bitmap优化</p><ul><li>使用适当分辨率和大小的图片</li><li>及时回收内存。使用完bitmap后，及时使用bitmap.recycle() 方法释放内存资源。3.0 后Bitmap 放在堆里面，由GC管理，不要在手动调用了</li><li>使用图片缓存。内存缓存LRUCACHE 和 硬盘缓存 DiskLruCache </li></ul><p>代码优化<br>使用静态方法，它比普通方法会提高15%左右的访问速度；<br>尽量不要使用枚举，少用迭代器<br>对Cursor、Receiver、Sensor、File等对象，要非常注意对它们的创建、回收与注册、解注册；<br>使用SurfaceView来替代view进行大量的、频繁的绘图操作；<br>尽量使用视图缓存，而不是每次都执行inflate方法解析视图。</p><p>3.Lint工具</p><p>写完布局后，AS 右边如果有修改意见会用黄色标注</p><p>4.使用Android Studio 的Memory Monitor 工具<br><img src="http://7xjkin.com1.z0.glb.clouddn.com/10.1.png" srcset="/img/loading.gif" alt=""></p><p>5.使用TraceView 工具优化App性能</p><p>待补充，分析TraceView 日志</p><p>6.使用MAT工具分析App内存状态</p><p>待补充， 内存分析工具</p><hr><h3 id="第十二章"><a href="#第十二章" class="headerlink" title="第十二章"></a>第十二章</h3><p>ndroid 5.x 新增特性分析</p><ol><li><p>Material Design 介绍</p></li><li><p>Material Design 主题<br>@android:style/Theme.Material<br>@android:style/Theme.Material.Light<br>@android:style/Theme.Material.Light.DarkActionBar</p></li><li><p>Palette</p></li><li><p>X 新增的Palette 让我们能够从Bitmap 中提取颜色，从而让主题能够动态适应当前页面的色调。Android 内置了几种提取色调的种类Vibrant(充满活力的),Vibrant dark(充满活力的黑), Vibrant light, Muted(柔和的), Muted dark, Muted light。 </p></li></ol><ul><li>使用前记得在build.gradle 中添加依赖compile ‘com.android.support:palette-v7:23.2.1’。</li><li>可以通过传递一个Bitmap 对象给Palette， 并调用它的Palette.generate() 静态方法或者Palette.generateAsync() 方法来创建一个Palette。书上写的这两种方法已经被废弃，新的使用方法是：Palette.from(bitmap).generate(new Palette.PaletteAsyncListener())。</li><li>接下来可以使用getter 方法来检索相同的色调。这写色调就是上面列出来的那些。</li></ul><ol start="4"><li><p>阴影效果<br>View增加了Z属性，对应垂直方向上的高度变化，Z由elevation和translationZ两部分组成(Z=elevation+translationZ)，它们都是5.X引入的新属性。elevation是静态的成员，translationZ可以在代码中用来实现动画效果。</p></li><li><p>Tint 和 Clipping<br>Tinting的使用就是配置tint和tintMode就可以了，tint通过修改图像的alpha遮罩来修改图像的颜色，从而达到重新着色的目的。<br>clipping可以改变一个view的外形，要使用它，首先需要使用ViewOutlineProvider来修改outline，然后再通过setOutlineProvider将outline作用给view。</p></li><li><p>RecyclerView 和 CardView<br>RecyclerView和CardView是support-v7包中新添加的组件，使用它们需要引用依赖<br>RecyclerView也具有ListView一样的item复用机制，系统在写Adapter 的时候强制要使用ViewHolder 复用，在onCreateViewHolder中绑定item中的view ，onBindViewHolder 中绑定数据和视图的关联</p></li><li><p>Activity 过度动画</p></li></ol><ul><li>5.0 之前提供了overridePenddingTransition(int inAnim, int outAnim)来实现的</li><li>5.0 之后提供了进入，退出和共享元素3中类型。</li><li>其中进入，退出包括explode(分解)。 slide(滑动)，fade(淡入淡出)； \</li><li>共享元素包括changeBounds（改变目标视图的布局边界），changeClipBounds (裁剪目标视图的边界)，changeTransform(改变目标是图的缩放比例和旋转角度)， changeImageTransform（改变目标图片的大小和缩放比例）</li></ul><hr><p>A-&gt;B<br>先看如何设置进入，退出动画</p><ul><li><p>只需要在startActivity（intent， ActivityOptions.makeSceneTransitionAnimation(this).toBundle()）;</p></li><li><p>在BActivity 中，设置getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS);</p></li><li><p>接着在B中就可以设置进入动画getWindow().setEnterTransition(new Explode()); 或者退出动画getWindow().setExitTransition(new Slide());</p></li></ul><hr><p>接着看下如何设置共享动画</p><ul><li>首先在A布局中要共享的item上加上 android:transitionName=”abc” ，接着在B要共享的item 上也加上 android:transitionName=”abc”。 注意两者的名字必须要相同</li><li>共享元素时按下面启动，如果有多个元素共享，需要使用Pair 配对</li></ul><pre><code class="Java"> // 创建单个共享元素       startActivity(intent,              ActivityOptions.makeSceneTransitionAnimation(                       this, view, &quot;share&quot;).toBundle());        startActivity(intent,                ActivityOptions.makeSceneTransitionAnimation(                        this,                        // 创建多个共享元素                        Pair.create(view, &quot;share&quot;),                        Pair.create(fab, &quot;fab&quot;)).toBundle());</code></pre><hr><ol start="8"><li>Ripple 效果</li></ol><ul><li>//波纹有边界 android:background=”?android:attr/selectableItemBackground”</li><li>//波纹无边界 android:background=”?android:attr/selectableItemBackgroundBorderless”</li></ul><ol start="9"><li><p>Circular Reveral 效果: 圆形展开动画效果</p><pre><code class="Java">//  view， 动画开始x， 动画开始y， 动画开始半径， 动画结束半径public static Animator createCircularReveal(View view,     int centerX,  int centerY, float startRadius, float endRadius) { return new RevealAnimator(view, centerX, centerY, startRadius, endRadius);}</code></pre></li><li><p>View state changes Animation<br>在Android 5.X中，可以使用动画来作为视图改变的效果，有两种方式来实现该动画：StateListAnimator和animated-selector。<br>StateListAnimator是将动画效果(objectAnimator)配置到原来的selector的item中来实现的<br>animated-selector是一个状态改变的动画效果selector，MD中很多控件设计用到了animated-selector，例如check-box</p></li><li><p>Notification<br>todo ： 待更新</p></li></ol><hr><p><a href="https://github.com/zubinxiong/AndroidHeroDemo" target="_blank" rel="noopener">GithubDemo地址</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 群英传读书笔记3</title>
    <link href="/2016/06/01/Android%E7%BE%A4%E8%8B%B1%E4%BC%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B03/"/>
    <url>/2016/06/01/Android%E7%BE%A4%E8%8B%B1%E4%BC%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B03/</url>
    
    <content type="html"><![CDATA[<h3 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h3><p>﻿  1. 视图动画(View 动画)</p><ul><li>Animation 框架定义了透明度AlphaAnimation， 旋转RotateAnimation， 缩放ScaleAnimation和位移TranslateAnimation几种常见的动画。</li><li>控制的是整个View， 实现原理是每次绘制视图时View所在的ViewGroup中的drawChild方法获取该View的Animation的Transformation值，然后调用canvas.concat(transformationToApply.getMatrix())，通过矩阵运算完成动画帧。如果动画没有完成，就继续调用invalidate方法，启动下次绘制来驱动动画，从而完成整个动画的绘制。</li><li>视图动画的问题在于当View 发生变化后，响应时间还停留在之前的位置</li><li>AnimationSet 动画集合</li><li>AnimationListener 设置动画的监听回调方法</li></ul><a id="more"></a><hr><p>2.属性动画</p><ul><li><p>3.0 之后新增了属性动画（Animator框架），使用的最多的是AnimatorSet 和 ObjectAnimator 配合<br>，使用ObjectAnimator进行更精细化的控制，只控制一个对象的一个属性，而使用多个ObjectAnimator组合到AnumatorSet 形成一个动画。而且ObjectAnimator 能够自动驱动，调用setFragmeDely(longframeDelay) 设置动画帧之间的间隙，在不影响动画效果的情况下减少CPU 资源消耗</p></li><li><p>ObjectAnimator</p><ul><li>创建通过静态工厂类直接返回一个ObjectAnimator 对象，参数包括一个对象和对象的属性名字，但这个属性必须有get 和 set 方法，内部会通过Java 反射调用set 函数修改对象属性值。同样也可以调用 setInterpolator 设置相应的插值器。常用的可以直接使用的属性动画的属性包括以下：</li><li>translationX和translationY：控制view从它布局容器左上角坐标偏移的位置；</li><li>rotation、rotationX和rotationY：控制view围绕支点进行2D和3D旋转；</li><li>scaleX和scaleY：控制view围绕着它的支点进行2D缩放；</li><li>pivotX和pivotY：控制支点位置，围绕这个支点进行旋转和缩放处理。默认情况下，支点是view的中心点；</li><li>x和y：控制view在它的容器中的最终位置，它是最初的左上角坐标和translationX、translationY的累计和；</li><li>alpha：控制透明度，默认是1（不透明）</li></ul></li><li><p>如果一个属性没有get，set方法，可以自顶一个一个Wrapper类，简介的给属性提供get/ set方法</p></li></ul><pre><code class="Java"> private static class WrapperView {        private View mTragetView;        public WrapperView(View traget) {            mTragetView = traget;        }        public int getWidth() {            return mTragetView.getLayoutParams().width;        }        public void setWidth(int width) {            mTragetView.getLayoutParams().width = width;            mTragetView.requestLayout();        }    }    // 调用方法    WrapperView wrapperView = new WrapperView(mButton);    ObjectAnimator animator = ObjectAnimator.ofFloat(wrapperView, &quot;translationX&quot;, 300);    animator.setDuration(1000);    animator.start();</code></pre><ul><li>PropertyValuesHolder<ul><li>类似视图动画中的AnimationSet，在属性动画中，如果针对同一个对象的多个属性，要同时作用多种动画可以使用PropertyValuesHolder</li></ul></li></ul><pre><code class="Java"> PropertyValuesHolder pvh1 = PropertyValuesHolder.ofFloat(&quot;translationX&quot;, 300);        PropertyValuesHolder pvh2 = PropertyValuesHolder.ofFloat(&quot;scaleX&quot;, 1f, 0, 1f);        PropertyValuesHolder pvh3 = PropertyValuesHolder.ofFloat(&quot;scaleY&quot;, 1f, 0, 1f);        ObjectAnimator.ofPropertyValuesHolder(mImageViews.get(0), pvh1, pvh2, pvh3).setDuration(1000).start();</code></pre><ul><li><p>ValueAnimator</p><ul><li>ValueAnimator 在属性中非常重要，ObjectAnimator 也是继承自它，它本身不提供任何动画效果，更像是数值发生器，用来产生具有一定规律的数字，从而让调用者来控制动画的实现过程。可以在ValueAnimator 的 AnimatorUpdateListener 中监听数值的变化, 从而完成动画的变换。</li></ul></li><li><p>动画的监听</p><ul><li>一个完整的动画有Start， Repeat ， End ， Cancel 四个过程，通过Android提供了接口，大部分时候我们只关注onAnimationEnd 事件，所有Android 也提供了一个AnimatorListenerAdapter来让我们选择必要的事件进行监听</li></ul></li></ul><pre><code class="Java">// 向左移动200        ObjectAnimator animator4 = ObjectAnimator.ofFloat(mImageViews.get(4),                &quot;translationX&quot;, -200F);        animator4.addListener(new Animator.AnimatorListener() {            @Override            public void onAnimationStart(Animator animation) {            }            @Override            public void onAnimationEnd(Animator animation) {            }            @Override            public void onAnimationCancel(Animator animation) {            }            @Override            public void onAnimationRepeat(Animator animation) {            }        });animator4.addListener(new AnimatorListenerAdapter() {            @Override            public void onAnimationEnd(Animator animation) {                super.onAnimationEnd(animation);            }        });</code></pre><ul><li><p>AnimatorSet</p><ul><li>对一个属性同时作用多个属性动画效果，前面的PropertyValuesHolder 实现了这样的效果。而AnimatorSet 不仅能实现，爱能够实现更为精准的顺序控制。通过 playTogether， playSequentially, animSet.play(),with().before(),after() 这些方法控制多个动画的协同</li></ul></li><li><p>在XML 中使用属性动画</p><ul><li>这个属性动画必须建在animator 文件夹下（Animator），anim文件夹下不起作用（Animation）</li></ul></li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:duration=&quot;1000&quot;    android:propertyName=&quot;scaleX&quot;    android:valueFrom=&quot;1.0&quot;    android:valueTo=&quot;2.0&quot;    android:valueType=&quot;floatType&quot;&gt;&lt;/objectAnimator&gt;</code></pre><pre><code class="Java">    // 调用xml文件中的属地动画    Animator animator = AnimatorInflater.loadAnimator(this, R.animator.scale_x);    animator.setTarget(mImageViews.get(0));    animator.start();</code></pre><ul><li>在Android 3.0 之后，View 增加了 animate 方法来直接驱动属性动画,可以理解为属性动画的简写方法</li></ul><pre><code class="Java">imageView.animate().alpha(0).y(100).setDuration(1000)        .setListener(new Animator.AnimatorListener() {            @Override            public void onAnimationStart(Animator animation) {            }            @Override            public void onAnimationEnd(Animator animation) {            }            @Override            public void onAnimationCancel(Animator animation) {            }            @Override            public void onAnimationRepeat(Animator animation) {            }        });</code></pre><ul><li>布局动画<ul><li>布局动画是指作用在ViewGroup 上，给ViewGroup 增加View 时添加一个动画过度效果。</li><li>最简单的是在ViewGroup 的xml 中新增 <strong>android:animateLayoutChanges=”true”</strong>，这样当ViewGroup 添加子View的时候，子View会呈现逐渐显示的过渡效果，这个是Android默认的效果切无法替换</li><li>可以通过LayoutAnimationController 类来自定义一个子View 的过度效果</li><li>LayoutAnimationController 第一个参数是需要作用的动画，第二个参数是每个子View的delay事件。当delay事件不为0时，可以设置子View显示的顺序<ul><li>LayoutAnimationController.ORDER_NORMAL 顺序</li><li>LayoutAnimationController.ORDER_RANDOM 随机</li><li>LayoutAnimationController.ORDER_REVERSE 反序</li></ul></li></ul></li></ul><pre><code class="Java">// 设置子View 的过度动画效果        LinearLayout ll = (LinearLayout) findViewById(R.id.ll);        // 设置过渡效果        ScaleAnimation sa = new ScaleAnimation(0, 1, 0, 1);        sa.setDuration(2000);        // 设置布局动画的显示属性        LayoutAnimationController lac = new LayoutAnimationController(sa, 0.5F);        lac.setOrder(LayoutAnimationController.ORDER_NORMAL);        // 为ViewGroup 设置布局动画</code></pre><ul><li>Interpolator （插值器）<ul><li>这部分可参考<a href="https://developer.android.com/reference/android/R.interpolator.html" target="_blank" rel="noopener">文档</a>， 常用的也没有几个插值 </li></ul></li></ul><hr><ul><li>自定义动画<ul><li>创建自定义动画，只需要实现它的applyTransformation 的逻辑就可以了，不过通常还需要覆盖父类的initialize方法来实现初始化工作。</li><li>applyTransformation(float interpolatedTime,Transformation t)  <strong>第一个参数是插值器的时间因子，第二个是矩阵的封装类</strong> 一般用这个类获得当前的矩阵对象</li></ul></li></ul><hr><ul><li><p>SVG 动画</p><ul><li><p>Android 在 5.x之后增加了对SVG适量图形的支持</p><p>先了解一下什么是SVG:</p></li><li><p>可伸缩矢量图形（Scaleable Vector Graphics）</p></li><li><p>定义用于网格的机遇矢量的图形</p></li><li><p>使用XML 格式定义图形</p></li><li><p>图像在放大或改变尺寸的情形下其图形质量不会有所损失</p></li><li><p>万维网联盟的标准</p></li><li><p>与DOM 和 XSL 之类的 W3C 标准是一个整体</p></li></ul></li><li><p>使用<path> 标签创建SVG，就像用指令控制一只画笔，例如移动画笔到某一坐标，画一条线，画一条曲线等。<path> 标签所支持的指定有以下几种：</p><ul><li>M = moveto(M X,Y) ； 将画笔移动到指定的坐标位置，未发生绘制</li><li>L = lineto（L X,Y）; 画直线到指定的坐标位置</li><li>H = horizontal lineto（H X） ； 画水平线到指定的X坐标位置</li><li>V = vertical lineto（V Y）； 画垂直线到指定的Y坐标</li><li>C = curveto(C X1, Y1, X2, Y2, ENDX, ENDY) ; 三次贝塞尔曲线</li><li>S = smooth curveto（S, X2， Y2， ENDX, ENDY） 三次贝塞尔曲线</li><li>Q = quadratic Belzier curve（Q X,Y, ENDX, ENDY） 二次贝塞尔曲线</li><li>T = smooth quadratic Belzier curveto（T ENDX, ENDY） 映射前面路径后的终点</li><li>A = elliptical Arc（A, RX, RY, XROTATION, FLAG1， FLAG2， X, Y） 弧线</li><li>Z = closepath（）； 关闭路径</li></ul></li><li><p>注意事项</p><ul><li>坐标轴以(0,0) 为中心，x轴向右，y轴向下</li><li>所有指令大小写均可，大写绝对定位，参照全局坐标系，小写相对定位，操作父容器坐标系</li><li>指令和数据间的空格可以省略</li><li>同一指令出现多次可以只用一个</li></ul></li><li><p>SVG 参数的写法固定且复杂，完全可以使用程序实现，所以一般通过SVG 编辑器来编辑SVG 图形。<br>书中给出了一个编辑的<a href="http://editor.method.ac" target="_blank" rel="noopener">网站</a></p></li><li><p>Android 中使用SVG </p><ul><li>Google 在 5.x 后提供了两个新的API 来帮助支持SVG ：VectorDrawable， AnimatedVerctorDrawable。其中 VectorDrawable 让你可以创建基于XML 的SVG 图形，并结合AnimatedVectorDrawable 来实现动画效果.具体的实现效果可以参考demo</li></ul></li></ul><hr><p><a href="https://github.com/zubinxiong/AndroidHeroDemo" target="_blank" rel="noopener">GithubDemo地址</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 群英传读书笔记2</title>
    <link href="/2016/05/31/Android%E7%BE%A4%E8%8B%B1%E4%BC%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B02/"/>
    <url>/2016/05/31/Android%E7%BE%A4%E8%8B%B1%E4%BC%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B02/</url>
    
    <content type="html"><![CDATA[<h3 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h3><p>﻿1. Android 上的几种坐标</p><ul><li>Android 坐标系</li></ul><p>在Android中，将屏幕左上角的顶点为坐标系原点。<br>系统提供了getLocationOnScreen(int location[]) 这样的方法获取Android坐标系中点的位置。另外在触摸事件中使用getRawX(). getRawY() 方法获得的坐标同样是Android坐标系中的坐标</p><a id="more"></a><p><img src="http://7xjkin.com1.z0.glb.clouddn.com/5.1.jpg" srcset="/img/loading.gif" alt=""></p><ul><li>视图坐标系</li></ul><p>它描述的了子视图在父视图中的位置关系。不过在视图坐标系是以父视图左上角为原点</p><p><img src="http://7xjkin.com1.z0.glb.clouddn.com/5.2.jpg" srcset="/img/loading.gif" alt=""></p><p><img src="http://7xjkin.com1.z0.glb.clouddn.com/5.3.jpg" srcset="/img/loading.gif" alt=""></p><p><a href="http://www.linuxidc.com/Linux/2015-11/125391.htm" target="_blank" rel="noopener">图片地址</a></p><p>2.实现滑动的7种方法</p><p>2.1 layout 方法:</p><ul><li>View 在进行绘制时，会调用onLayout()方法设置显示的位置。同样，可以通过修改View的left，top，right，bottom四个属性来控制View的坐标.因此我们可以在每次回调onTouchEvent 的时候,来获取触摸点的坐标,然后在ACTION_DOWN中记录触摸点的坐标。然后在ACTION_MOVE中计算偏移量，并应用到layout中。</li></ul><p>2.2 offsetLeftAndRight(offsetX) 和 offsetTopAndBottom(offsetY)</p><ul><li>这个方法相当于系统对左右，上下移动的一个封装。计算出便宜量后直接使用即可，与layout效果相同</li></ul><p>2.3 LayoutParams</p><ul><li><p>LayoutParams 保存了一个View的布局参数。因此可以在程序中，通过改变LayoutParams来动态地修改一个布局的位置参数，从而达到改变View位置的效果。可以用getLayoutParams()来获取一个View的LayoutParams。计算偏移量与上面相同，获取到偏移量之后用setLayoutParams。</p></li><li><p>这个View 需要有父布局，不然无法获取到LayoutParams</p></li><li><p>在通过LayoutParams 来改变一个View的位置时，通常改变的是这个View的Margin属性，所以除了使用布局的LayoutParams之外，还可以使用ViewGroup.MarginLayoutParams 实现</p></li></ul><p>2.4 scrollTo 与 scrollBy</p><ul><li><p>在一个View 中，系统提供了scrollTo和scrollBy来改变一个View的位置。scrollTo(x, y) 是移动到某一个点，scrollBy(dx, dy) 表示的是移动的增量</p></li><li><p>当我们在上面的代码中获得偏移量之后scrollBy(offsetX, offsetY)发现并没有移动。 因为这个方法移动的是View 的content例如textview，移动的就是它的文本。ViewGroup中用这两个方法，移动的将是所有子VIew，因此要移动的时候应该这样处理 ((View)getParent()).scrollBy(offsetX, offsetY);</p></li><li><p>当我们调用的时候scrollBy的时候可以理解为外面的盖子在动，所有当直接使用时view往反方向走了，所以这个地方offsetx和offsetY都应该为负即反方向, 参考下图</p></li></ul><p><img src="http://7xjkin.com1.z0.glb.clouddn.com/5.4.jpg" srcset="/img/loading.gif" alt=""></p><p>2.5 Scroller</p><ul><li><p>Scroller 类与scrollTo 和 scrollBy 方法非常的类似，但是上面两个方法都是瞬时的，view 会突然的移动到某个位置， 通过Scroller 类方法可以实现平滑的移动</p></li><li><p>使用Scroller 类需要如下三个步骤</p><ul><li>初始化Scroller mScroller = new Scroller(context)</li><li>重写computeScroll() 方法，实现模拟滑动</li><li>startScroll 开启模拟过程, 调用startScroll(int startX, int startY, int dx, int dy)， 其实坐标和位移。在获取坐标的时候，通常可以使用view.getScrollX() 方法来获取父视图中content 所滑动到点的坐标，注意这个值的政府和scrollBy 和 scrollTo 中一样。</li></ul></li></ul><p>2.6 属性动画</p><ul><li>这部分内容在第7张会详细介绍，这里不过多介绍</li></ul><p>2.7 ViewDragHelper</p><ul><li><p>在自定义viewgroup中，很多效果都包含用户手指去拖动其内部的某个View（eg:侧滑菜单等）,针对具体的需要去写好onInterceptTouchEvent 和 onTouchEvent 这两个方法很不容易，需要自己去处理，包括多手指的处理、加速度检测等等。 官方在V4的支持包里面提供了ViewDragHelper 让我们方便的去自定义一个ViewGroup</p></li><li><p>初始化ViewDragHelper： mViewDragHelper = ViewDragHelper.create(this, callback);</p></li><li><p>拦截事件，将事件传递给ViewDragHelper 处理</p></li><li><p>处理computeScroll(), 因为ViewDragHelper 内部也是通过Scroller 来实现平滑移动的。通常情况下可以使用下面的代码</p><pre><code class="Java">@Override  public void computeScroll() {      if (mViewDragHelper.continueSettling(true)) {          ViewCompat.postInvalidateOnAnimation(this);      }  }</code></pre></li><li><p>处理Callback </p><ul><li><p>IDE 自动帮我们重写了一个方法 tryCaptureView。 通过这个方法，可以指定在创建ViewDragHelper时，参数parentView中哪一个子View 可以移动</p></li><li><p>clampViewPositionVertical 和 clampViewPositionHorizontal 分别对应着垂直和水平两个方向的移动，默认是返回0表示不发生滑动，如果要实现滑动的效果，这两个方法基本上是必须要重写的</p></li><li><p>onViewReleased 方法，表示手指放开时的操作，内部实现也是Scoller实现，之前是监听ACTION_UP 实现的</p></li></ul></li><li><p>书上只介绍了一些简单的用法，更深入的可以参考<a href="http://blog.csdn.net/lmj623565791/article/details/46858663" target="_blank" rel="noopener">这篇文章</a>了解</p></li></ul><hr><h3 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h3><p>﻿<br>1.屏幕的尺寸信息</p><table><thead><tr><th>密度</th><th>ldpi</th><th>mdpi</th><th>hdpi</th><th>xhdpi</th><th>xxhdpi</th></tr></thead><tbody><tr><td>密度值</td><td>120</td><td>160</td><td>240</td><td>320</td><td>480</td></tr><tr><td>分辨率</td><td>240x320</td><td>320x480</td><td>480x800</td><td>720x 1280</td><td>1080x1920</td></tr></tbody></table><ul><li>Android 中使用mdpi 即密度值为160 的屏幕作为标准，在这个屏幕上1px = 1dp, 同理可以转换得出在hdpi 中1dp = 1.5px， 在xhdpi 中1dp = 2px(如果设计只出ios的图，一般这个对应着 5s 的分辨率，即2x 的图), 在xxhdpi中 1dp = 3px</li></ul><p>常用的一些转换公式：</p><ul><li>ppi =  √（长度像素数² + 宽度像素数²） / 屏幕对角线英寸数</li><li>dp 已160ppi屏幕为标准，则1dp = 1px</li><li>dp * ppi / 160 = px</li><li>sp 是安卓的字体单位，以160PPI 屏幕为标准，当字体大小为100%时，1sp = 1px； sp * ppi /160 = px</li><li>Android 上获取这些参数的方法,<a href="http://blog.csdn.net/ithomer/article/details/6688883" target="_blank" rel="noopener">参考这篇文章</a></li></ul><hr><p>2.2D绘图基础</p><ul><li>系统通过Canvas 对象来提供绘图方法，包括drawPoint， drawLine，drawRect，drawVertices(多边形)，drawArc(弧)，drawCircle等。Paint 作为一个重要的元素，这里简单的列举下它的属性和相应的功能<ul><li>setAntiAlias() //设置画笔锯齿效果 ；setColor() // 设置画笔颜色 ；setARGB() // 设置画笔的ARGB值</li><li>setAlpha() // 设置画笔的Alpha 值； setStrokeWidth() // 空心边框的宽度；setStyle // 画笔的风格（空心实心）</li></ul></li></ul><hr><p>3.Android XML 绘图</p><p>这部分内容<a href="http://hujiaweibujidao.github.io/blog/2015/11/27/Android-Heros-Reading-Notes-3/" target="_blank" rel="noopener">hujiaweibujidao</a> 这篇博客写的非常清楚，而且也不是很难，我就直接copy过来了。感谢原作者的总结</p><ul><li>Bitmap<pre><code class="XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;bitmap  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  android:src=&quot;@[package:]drawable/drawable_resource&quot;  android:antialias=[&quot;true&quot; | &quot;false&quot;]  android:dither=[&quot;true&quot; | &quot;false&quot;]  android:filter=[&quot;true&quot; | &quot;false&quot;]  android:gravity=[&quot;top&quot; | &quot;bottom&quot; | &quot;left&quot; | &quot;right&quot; | &quot;center_vertical&quot; |                    &quot;fill_vertical&quot; | &quot;center_horizontal&quot; | &quot;fill_horizontal&quot; |                    &quot;center&quot; | &quot;fill&quot; | &quot;clip_vertical&quot; | &quot;clip_horizontal&quot;]  android:tileMode=[&quot;disabled&quot; | &quot;clamp&quot; | &quot;repeat&quot; | &quot;mirror&quot;] /&gt;</code></pre></li><li>Shape<pre><code class="XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape     xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;     android:shape=[&quot;rectangle&quot; | &quot;oval&quot; | &quot;line&quot; | &quot;ring&quot;] &gt;     &lt;corners        //当shape为rectangle时使用      android:radius=&quot;integer&quot;        //半径值会被后面的单个半径属性覆盖，默认为1dp      android:topLeftRadius=&quot;integer&quot;             android:topRightRadius=&quot;integer&quot;             android:bottomLeftRadius=&quot;integer&quot;             android:bottomRightRadius=&quot;integer&quot; /&gt;     &lt;gradient       //渐变      android:angle=&quot;integer&quot;             android:centerX=&quot;integer&quot;             android:centerY=&quot;integer&quot;             android:centerColor=&quot;integer&quot;             android:endColor=&quot;color&quot;             android:gradientRadius=&quot;integer&quot;             android:startColor=&quot;color&quot;             android:type=[&quot;linear&quot; | &quot;radial&quot; | &quot;sweep&quot;]             android:useLevel=[&quot;true&quot; | &quot;false&quot;] /&gt;     &lt;padding        //内边距      android:left=&quot;integer&quot;             android:top=&quot;integer&quot;             android:right=&quot;integer&quot;             android:bottom=&quot;integer&quot; /&gt;     &lt;size           //指定大小，一般用在imageview配合scaleType属性使用      android:width=&quot;integer&quot;             android:height=&quot;integer&quot; /&gt;     &lt;solid          //填充颜色      android:color=&quot;color&quot; /&gt;        &lt;stroke         //边框        android:width=&quot;integer&quot;             android:color=&quot;color&quot;             android:dashWidth=&quot;integer&quot;             android:dashGap=&quot;integer&quot; /&gt;&lt;/shape&gt;</code></pre></li><li>Layer:Layer在XML中定义Layer的语法，layer类似PS中图层的概念<pre><code class="XML">&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;  &lt;item android:drawable=&quot;@[package:]drawable/drawable_resource&quot; /&gt;  &lt;item android:drawable=&quot;@[package:]drawable/drawable_resource&quot; /&gt;  ......&lt;/layer-list&gt;</code></pre></li><li>Selector<pre><code class="XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;  &lt;!-- 默认时的背景图片--&gt;  &lt;item android:drawable=&quot;@drawable/pic1&quot;/&gt;  &lt;!-- 没有焦点时的背景图片 --&gt;  &lt;item android:drawable=&quot;@drawable/pic1&quot; android:state_window_focused=&quot;false&quot;/&gt;  &lt;!-- 非触摸模式下获得焦点并单击时的背景图片 --&gt;  &lt;item android:drawable=&quot;@drawable/pic2&quot; android:state_focused=&quot;true&quot; android:state_pressed=&quot;true&quot;/&gt;  &lt;!-- 触摸模式下单击时的背景图片--&gt;  &lt;item android:drawable=&quot;@drawable/pic3&quot; android:state_focused=&quot;false&quot; android:state_pressed=&quot;true&quot;/&gt;  &lt;!--选中时的图片背景--&gt;  &lt;item android:drawable=&quot;@drawable/pic4&quot; android:state_selected=&quot;true&quot;/&gt;  &lt;!--获得焦点时的图片背景--&gt;  &lt;item android:drawable=&quot;@drawable/pic5&quot; android:state_focused=&quot;true&quot;/&gt;&lt;/selector&gt;</code></pre></li></ul><hr><p>4.Android 绘图技巧</p><p>4.1 Canvas</p><ul><li><p>canvas.save()  保存之前已绘制的图形，之后的绘制在另一个图层上进行</p></li><li><p>canvas.restore()  可以类似PS 中的合并图层来理解，将我们在save之后和之前的图层合并</p></li><li><p>canvas.translate() 平移，调用后将原点从(0,0)移动到了(x,y) 之后的操作都是以x,y 为原点操作</p></li><li><p>canvas.rotate() 翻转, 和上面的平移效果类似，这个效果可以参考demo中<a href="https://github.com/zubinxiong/AndroidHeroDemo/blob/master/chapter6/src/main/java/me/ewriter/chapter6/clock/Clock.java" target="_blank" rel="noopener">Clock类</a>加深理解</p></li></ul><p>4.2 Layer图层</p><ul><li>Android 通过saveLayer() 方法， saveLayerAlpha() 方法将一个图层入栈，使用restore() 方法，restoreToCount 方法将一个图层出栈。 入栈的时候，后面的所有操作都发生在这个图层上，出栈的时候，则会把图像绘制到上层Canvas 上。详细的可以参考<a href="http://www.cnblogs.com/liangstudyhome/p/4143498.html" target="_blank" rel="noopener">这篇文章</a></li></ul><p>5.色彩特效处理</p><ul><li>主要是矩阵等处理，这部分内容稍后补充</li></ul><p>6.Android图像处理，画笔特效</p><p>6.1 PorterDuffXfermode</p><ul><li><p>图片列举了16 中 PorterDuffXfermode， 这个效果类似于集合的交集并集，PorterDuffXfermode 设置的是两个图层交集部分如何显示，dst 是先画的图层，src 是后画的图层</p></li><li><p>其中最常用的是DstIn 和 SrcIn 将矩形图片切成圆角矩形</p></li><li><p>实现一个圆角图片，先用一个普通画笔画一个Mask 遮罩层，再用带PorterDuffXfermode 的画笔将图像画在遮罩层上，这样就可以实现圆角的图片了。 书中还有另外一个刮刮卡的例子，我在代码上面新增了注释，比较直观可以直接看代码理解。<a href="https://github.com/zubinxiong/AndroidHeroDemo/blob/master/chapter6/src/main/java/me/ewriter/chapter6/xfermode/RoundRectXfermodeView.java" target="_blank" rel="noopener">RoundRectXfermodeView</a>， <a href="https://github.com/zubinxiong/AndroidHeroDemo/blob/master/chapter6/src/main/java/me/ewriter/chapter6/xfermode/XfermodeView.java" target="_blank" rel="noopener">XfermodeView</a></p></li></ul><p><img src="http://7xjkin.com1.z0.glb.clouddn.com/6.1.jpg" srcset="/img/loading.gif" alt=""></p><p>6.2 Shader着色器</p><ul><li>LinearGradient 线性Shader</li><li>RadialGradient 光束</li><li>SweepGradient 梯度</li><li>ComposeShader 混合</li><li>BimapShader 位图</li></ul><p>6.3 PathEffect</p><ul><li>暂时没用过这部分功能，详细的笔记稍后补充</li></ul><p>6.4 SurfaceView </p><ul><li><p>View 通过刷新来重绘视图的，Android系统通过VSYNC 信号来进行屏幕的重绘，刷新间隔为16ms，如果操作的逻辑太多，比如游戏界面需要频繁刷新就会阻塞主线程造成卡顿</p></li><li><p>SurfaceView 和 View 的区别</p><ul><li>View 主要用在主动更新的状况下，而 SurfaceView 主要适用于被动更新，例如频繁的刷新</li><li>View 在主线程中对画面进行刷新，而 SurfaceView 通常会通过一个子线程来进行页面刷新</li><li>View 在绘图时并没有使用双缓冲机制，而 SurfaceView 在底层实现机制中就已经实现了双缓冲机制</li></ul></li><li><p>SurfaceView 的使用</p><ul><li>创建自定义的SurfaceView 继承自 SurfaceView， 并实现两个接口 SurfaceHolder.Callback 和 Runnable</li><li>初始化 SurfaceView， 自定义的 SurfaceView 通常有下面三个变量， 初始化方法见下方</li></ul></li><li><p>通过lockCanvas方法获取Canvas对象进行绘制，并通过unlockCanvasAndPost方法对画布内容进行提交。每次调用<strong>lockCanvas</strong>拿到的Canvas都是同一个Canvas对象，所以之前的操作都会保留，如果需要擦除，可以在绘制之前调用drawColor方法来进行清屏。注意<strong>mHolder.unlockCanvasAndPost(mCanvas)</strong> 方法放到finally 中，保证每次的内容都被提交。</p></li></ul><pre><code class="Java">private SurfaceHolder mHolder;// 用于绘图的Canvasprivate Canvas mCanvas;// 子线程标志位private boolean mIsDrawing;private void initview() {    mHolder = getHolder();    mHolder.addCallback(this);    // 初始化Surfaceholder 并注册SurfaceHolder 的回调事件}</code></pre><hr><p><a href="https://github.com/zubinxiong/AndroidHeroDemo" target="_blank" rel="noopener">GithubDemo地址</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 群英传读书笔记1</title>
    <link href="/2016/05/28/Android%E7%BE%A4%E8%8B%B1%E4%BC%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B01/"/>
    <url>/2016/05/28/Android%E7%BE%A4%E8%8B%B1%E4%BC%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B01/</url>
    
    <content type="html"><![CDATA[<p>最近在重看Android 群英传，发现第一遍看下来还有挺多没消化的，第二遍干脆就把这些记下来发到博客上备忘好了</p><hr><p>###第一章</p><ul><li><p>介绍了Android 的体系架构及四大组件</p></li><li><p>Android 系统源码目录</p><ul><li><p>一个查看Android 源码的<a href="http://androidxref.com" target="_blank" rel="noopener">网站</a></p></li><li><p>整个结构关系图(Makefile,bionic,bootable….. vendor等)</p></li><li><p>/system/lib/ 存放几乎所有的共享库(.so)</p></li><li><p>/system/usr/ 保存用户的配置文件,如键盘布局,共享,时区文件等</p></li><li><p>/data/misc/    保存了大部分的Wi-Fi,VPN信息:</p><a id="more"></a></li></ul></li></ul><h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><ul><li>Android Studio的使用,这部分用的比较多,大部分操作都比较熟悉就不做过多的笔记了</li><li>adb的常用命令<ul><li>adb shell //进入了类似linux命令环境下</li><li>pm list packages -f 列出所有的package</li><li>adb shell am start -n 包名／包类 ＋ 类名 启动一个activity </li></ul></li></ul><h3 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h3><p>1.1  View 的测量,这个过程是在onmeasure()方法中进行<br>系统提供了一个MeasureSpec类. MeasureSpec 是一个32位int值. 其中高2位是测量的模式,低30位是测量的大小. </p><ul><li><p>EXACTLY<br>  精确模式,比如指定具体数值或者指定为match_parent 的时候</p></li><li><p>AT_MOST<br>即最大值模式,layout_width,layout_height 指定为wrap_content的时候</p></li><li><p>UNSPECIFIED<br>不指定大小测量模式,View 想多大就多大,通常情况下在绘制自定义 View 的时候才会使用</p></li></ul><hr><p>View 类默认的 onMeasure() 方法只支持EXACTLY 模式,如果不重写 onMeasure 方法的话就只能用match_parent 或者指定的大小. 如果要支持wrap_content 的使用,就必须重写onMeasure方法. </p><p>1.2 View 的绘制<br>测量好一个 View 之后,就可以简单地重写onDraw() 方法,并在Canvas对象上来绘制所需要的图形<br>一般情况下可以重写 View 类中的onDraw 方法,,onDraw 中有一个参数,就是Canvas 对象.</p><hr><p>2.1 ViewGroup 的测量<br>ViewGroup 在测量时通过遍历所以子View,从而调用子View的Measure 方法,获得每一个子View的测量结果,前面所说的对View 的测量,就是在这里进行的.<br>当子View测量完毕后,就要将子View 放到合适的地方,这个过程就是View 的Layout 过程.<br>在自定义ViewGroup时,通常会去重写onLayout方法来控制其子View显示位置的逻辑. 同样,如果需要支持wrap_content属性,那么它还需要重写onMeasure方法. 这点与View是相同的. </p><p>2.2 ViewGroup 的绘制<br>ViewGroup 通常情况不需要绘制,如果不是指定了ViewGroup的背景色,那么ViewGroup的onDraw()方法都不会被调用. 但是ViewGroup会使用dispatchDraw()方法绘制子View</p><hr><p>自定义View时:<br>通常会去重写onDraw 方法来绘制View 的显示内容. 如果还需要使用<br>wrap_content 属性,还需要重写onMeasure 方法. 自定义View 中还有一些比较重要的回调方法. </p><ul><li>onFinishInflate() 从XML 加载组件后回调</li><li>onSizeChanged 组件大小改变时回调</li><li>onMeasure 回调改方法来进行测量</li><li>onLayout 回调该方法来确定显示的位置</li><li>onTouchEvent 监听到触摸事件时回调</li></ul><hr><p>2.3 事件传递</p><ul><li>ViewGroup (dispatchTouchEvent, onInterceptTouchEvent)比View(dispatchTouchEvent) 的传递多了一个onInterceptTouchEvent方法</li><li>View 和ViewGroup 事件的消费是一致的都是在onTouchEvent中</li><li>事件的传递是从上到下的在这个例子重视 MyViewGroupA - MyViewGroupB - MyView(返回true, 拦截了, 返回false,不拦截 继续)</li><li>事件的处理是传递到底部返回到顶部: MyView - MyGroupB - MyGroupA (true,处理了, false , 没处理)</li></ul><p>具体可以看我在github上传的代码,里面有详细的注释</p><hr><h3 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h3><ol><li><p>使用ViewHolder 优化</p></li><li><p>设置listview显示在第几个item,listview.setSelection(N),这个方法和scrollTo一样是瞬时的,如果要平滑移动,用下面的方法</p><pre><code class="Java">mListView.smoothScrollBy(distance, duration);mListView.smoothScrollByOffset(offset);mListView.smoothScrollToPosition(index);</code></pre></li><li><p>ListView 的滑动监听</p><ul><li><p>ontouchelistener</p></li><li><p>onScrollListener</p><pre><code class="Java">SCROLL_STATE_FLING // 手指抛动时,惯性滑动的状态SCROLL_STATE_IDLE // 停止滑动SCROLL_STATE_TOUCH_SCROLL // 正在滑动</code></pre></li></ul></li></ol><hr><p><a href="https://github.com/zubinxiong/AndroidHeroDemo" target="_blank" rel="noopener">GithubDemo地址</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>uiautomator测试入门</title>
    <link href="/2015/11/10/uiautomator%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8/"/>
    <url>/2015/11/10/uiautomator%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>之所以要去了解这测试工具是因为公司没有专门的测试人员，于是测试工作也得自己上了。画了半天的时间了解了下基本的操作，但是因为是第一次接触这个东西，只涉及了一些基本的东西，文章中难免有错，望谅解，接下来就开始介绍吧。</p><ul><li>Uiautomator简介</li></ul><p><a href="http://developer.android.com/tools/testing-support-library/index.html" target="_blank" rel="noopener">官网链接</a>，更具体的内容就不做更多的介绍了。稍微概一下，Uiautomator是为了方便测试而引进的一个测试工具。可以在手机上模拟常用操作，比如说点击home键，返回键，点击view上某个特定的button，textview等。通过这一些列的方法测试能否正常运行。</p><a id="more"></a><ul><li>如何使用</li></ul><p>因为我使用的是Android Studio，所以接下来的一些列环境配置和操作都是针对AS的，关于eclipse下的配置，请自行Google。</p><ol><li><p>添加依赖，在build.gradle中添加下列依赖，同步完成后就可以开始写具体的内容了</p><pre><code class="java">androidTestCompile &#39;com.android.support.test.uiautomator:uiautomator-v18:2.1.2&#39;</code></pre></li><li><p>新建一个CaculateTest.java类，具体的位置如下图所示，我们让这个类继承InstrumentationTestCase类，关于我们测试的方法则必须要已test开头才可以，不然则不会运行<br><img src="http://7xjkin.com1.z0.glb.clouddn.com/structure.png" srcset="/img/loading.gif" alt=""></p></li><li><p>常用方法<br>关于UI Automator的API主要就只有几个，包括UiCollection、UiObject、UiScrollable、UiSelector、Configurator这几个。我这边主要介绍UiObject、UiScrollable、UiSelector这三个，主要是这几个用的比较多。其他两个也非常简单大家看文档应该一会就能明白。</p><ul><li><p>UiObject：表示当前能看到的Ui元素，比如当前视图上有button或者edittextview，当我们需要点击button时就需要先通过UiObject获取到这个button</p></li><li><p>UiScrollable: 用来获取可以滑动的view，比如说listview，viewpager等</p></li><li><p>UiSelector: 用来查询组件的方法，常用的有text，resourceid，class等。</p></li><li><p>Uidevice： 机器的实例，获取到当前的机器，可通过下述代码获取</p><pre><code class="java">mDevice = UiDevice.getInstance(getInstrumentation());</code></pre></li><li><p>uiautomatorviewer： sdk里面提供的工具，在tools文件里面。可以查看手机view的id，text等值，这样就不用每次都去原来的文件里面查看了，给个截图吧，如下图所示：<br><img src="http://7xjkin.com1.z0.glb.clouddn.com/UIAutomatorView.png" srcset="/img/loading.gif" alt=""></p></li></ul></li><li><p>上面说了那么多话，下面来点例子吧，这样更好理解，主要操作就是包括滚动桌面找到指定app，打开并登录。写完后再这个类上右键单击选择run，之后就等着手机上自动运行就可以了。<br><img src="http://7xjkin.com1.z0.glb.clouddn.com/main.png" srcset="/img/loading.gif" alt=""><br><img src="http://7xjkin.com1.z0.glb.clouddn.com/openapp.png" srcset="/img/loading.gif" alt=""><br><img src="http://7xjkin.com1.z0.glb.clouddn.com/login.png" srcset="/img/loading.gif" alt=""></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>uiautomator</tag>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>联想newifi mini刷Pandorabox及SS相关配置</title>
    <link href="/2015/10/26/%E8%81%94%E6%83%B3newifi%20mini%E5%88%B7Pandorabox%E5%8F%8ASS%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/"/>
    <url>/2015/10/26/%E8%81%94%E6%83%B3newifi%20mini%E5%88%B7Pandorabox%E5%8F%8ASS%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>  因为最近手机从越狱状态升级到了 iOS9 ，手机上就没办法用ss了，其实之前手机上因为用不了chacha20的加密就几乎全部转向Android手机了，于是就想着直接从路由下手好了，这样手机就不用再设置些其他的东西了。<br>  关于路由器的挑选，因为自己的要求并不高，能够刷openwrt的系统就可以了，所以就买了联想的这个newifi mini，某东价格99。吐槽一下其实本来想买小米的路由器的，但是翔米的期货一直买不到，就转向了上面那个和小米配置几乎一样的路由器。好了下面开始具体的操作了。<br>  <a id="more"></a><br>  因为我对网络这一块不是特别的了解，因此下面这则步骤大部分是网上找来的教程，同时根据自己在配置过程中遇到的问题总结出来的经验，里面可能有些不对的地方还请指出，本文的主要目的还是总结备份一下，如果能帮助到有需要的人那也是意外收获了。下面就开始具体的步骤吧。</p><hr><ol><li>拿到手的第一步当然就是刷系统了，从京东拿到手之后检查了一下发现基本功能没问题就开始刷了。刷系统的过程还是比较简单的，这部分内容我也不打算具体介绍了，因为网上已经有很多这哥教程了，并没有什么特别的，只是要稍微耐心等待而已。这里给出一篇参考文章：<a href="http://www.crazycen.com/internet/2132.html" target="_blank" rel="noopener">戳这里</a>；pandorabox下载地址：<a href="http://downloads.openwrt.org.cn/PandoraBox/Lenovo-Y1_RY-1S/firmware/stable/" target="_blank" rel="noopener">戳这里</a></li><li>系统装好了之后插上网线就会看到有下面这个wifi出现了,还有一个5G的，但是我这里没有截出来。大家随便连上任意一个就可以了<img src="http://7xjkin.com1.z0.glb.clouddn.com/wifi.png" srcset="/img/loading.gif" alt="">，在浏览器里面输入192.168.1.1就会出来熟悉的路由器登录界面了，默认的用户名和密码是root和admin,建议大家登录后尽快改密码，还有默认的wifi也是没有密码的，大家尽快修改密码。</li><li>在安装shadowsocks之前我们还有一件事情需要做，那就是配置更新源，默认的更新源是有问题的，这样是无法更新软件，安装我们需要的东西的，这里可以通过ssh可以进行响应的修改，但是通过网页版修改会简单许多，所以就通过网页版来修改了。具体位置是：系统-&gt; 软件源 -&gt; 配置。我这里就偷懒只给出newifi mini的配置了，具体的解释大家可以看<a href="http://www.phpgao.com/xiaomi_router_opkg.html" target="_blank" rel="noopener">这篇文章</a></li></ol><pre><code class="xml">dest root /dest ram /tmplists_dir ext /var/opkg-listsoption overlay_root /overlay# noticedest usb /mnt/sdb1/opkgarch all 100arch ramips_24kec 200arch ramips 300arch mips 400arch unkown 500src/gz barrier_breaker_base http://mirrors.ustc.edu.cn/openwrt/barrier_breaker/14.07/ramips/mt7620a/packages/basesrc/gz barrier_breaker_luci http://mirrors.ustc.edu.cn/openwrt/barrier_breaker/14.07/ramips/mt7620a/packages/lucisrc/gz barrier_breaker_management http://mirrors.ustc.edu.cn/openwrt/barrier_breaker/14.07/ramips/mt7620a/packages/managementsrc/gz barrier_breaker_oldpackages http://mirrors.ustc.edu.cn/openwrt/barrier_breaker/14.07/ramips/mt7620a/packages/oldpackagessrc/gz barrier_breaker_packages http://mirrors.ustc.edu.cn/openwrt/barrier_breaker/14.07/ramips/mt7620a/packages/packagessrc/gz barrier_breaker_routing http://mirrors.ustc.edu.cn/openwrt/barrier_breaker/14.07/ramips/mt7620a/packages/routingsrc/gz barrier_breaker_telephony http://mirrors.ustc.edu.cn/openwrt/barrier_breaker/14.07/ramips/mt7620a/packages/telephonysrc/gz openwrt_dist http://openwrt-dist.thankgfw.ml/releases/ramips/packagessrc/gz openwrt_dist_luci http://openwrt-dist.thankgfw.ml/releases/luci/packages</code></pre><p>4 . 配置好了软件源之后，剩下的都需要在几乎都需要在终端里面进行了，Windows平台可自行找相对应的软件，登录成功后的界面如下图所示：<img src="http://7xjkin.com1.z0.glb.clouddn.com/ssh.png" srcset="/img/loading.gif" alt="">. 接下来就是一串命令了，这部分内容就不做具体的解释，只给出简单的注释了：详细的可以<a href="http://www.phpgao.com/xiaomi_router_shadowsocks_libev_spec.html" target="_blank" rel="noopener">看这里</a></p><pre><code>##停止进程killall ss-localkillall ss-redirkillall ss-tunnel# 备份配置文件mv /etc/config/shadowsocks /etc/config/shadowsocks_old# 备份执行文件cd /usr/binmv ss-local ss-local.oldmv ss-redir ss-redir.oldmv ss-tunnel ss-tunnel.old#更新一下源opkg update#安装shdowsocks-lubev-spec 和 luci-app-shadowsocks-specopkg install shadowsocks-libev-specopkg install luci-app-shadowsocks-spec</code></pre><p>上面安装过程中可能会出现下面这些问题：</p><ul><li>shadowsocs-libev 安装不上很有可能是因为新版本在pandroabox上不能够正常运行的原因，请下载相应的旧版本2.1.4。可以从<a href="http://sourceforge.net/projects/openwrt-dist/files/shadowsocks-libev/" target="_blank" rel="noopener">此处下载</a></li><li>如果按照上述方法执行后还是不能正常运行，请检查软件源是否配置正确。</li></ul><p>5.接下来就是shadowsocks的配置了。这部分和服务器端的配置差不多，在/etc/shadowsocks/config.json 下写你的配置文件,配置完成后输入命令运行起来shadowsocks，不过这里有一个问题就是如果你服务端填写的不是ip合适网址的话还需要进一步的设置。这个留到后面和dns设置一起讲</p><pre><code class="json">/etc/init.d/shadowsocks enable/etc/init.d/shadowsocks start</code></pre><pre><code class="json">{    &quot;server&quot;: &quot;xx.x.x.x&quot;,    &quot;server_port&quot;: 23456,    &quot;local&quot;: &quot;0.0.0.0&quot;,    &quot;local_port&quot;: 1080,    &quot;password&quot;: &quot;xxxosihd&quot;,    &quot;timeout&quot;: 60,    &quot;method&quot;: &quot;rc4-md5&quot;}</code></pre><p>6.之后就是在网页端的shadowsocks端口转发和china-dns和DHCP/DNS设置相关的东西了，这个可以才看下面几个截图<img src="http://7xjkin.com1.z0.glb.clouddn.com/CONFIG1.png" srcset="/img/loading.gif" alt=""> <img src="http://7xjkin.com1.z0.glb.clouddn.com/CONFIG2.png" srcset="/img/loading.gif" alt=""><br><img src="http://7xjkin.com1.z0.glb.clouddn.com/DNS%E8%BD%AC%E5%8F%91.png" srcset="/img/loading.gif" alt="dns转发">)<img src="http://7xjkin.com1.z0.glb.clouddn.com/hulue.png" srcset="/img/loading.gif" alt="忽略文件"></p><p>7.按照<a href="http://www.phpgao.com/carzy_router.html" target="_blank" rel="noopener">这篇文章</a>里面说的，其实到这里就已经结束了，现在就可以自动区分内外网，对某些屏蔽网站能够自动访问了，但是我在实际中发现这样并不能起作用，只能够访问Google，但是twitter，facebook，youtube这些网站还是访问不了，返回的错误信息都是dns错误，网上找了一下似乎是dns污染造成的，所以打算用dnsmasq的方式手动添加这些网站。</p><ul><li>具体的步骤是先在/etc/dnsmasq.conf的末尾加入指定目录</li></ul><pre><code class="json">conf-dir=/etc/dnsmasq.d# 然后在ssh中输入下面的命令mkdir /etc/dnsmasq.d/vim   /etc/dnsmasq.d/gfw.conf# 输入类似下面这种地址，后面的5300是本地的转发端口#FaceBookserver=/.facebook.com/127.0.0.1#5300</code></pre><p>关于上面gfw.conf这个维护目录可参考github上的这个<a href="https://github.com/felixonmars/dnsmasq-china-list" target="_blank" rel="noopener">项目</a></p><hr><p>整个安装过程到这里基本就结束了，拖了好久终于把这个写完了，其实还有之前坑了的gradle笔记系列，因为换了工作比较忙就没时间写，之后如果我没<del>犯懒癌</del>的话会继续补起来的。 = = </p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>openwrt</tag>
      
      <tag>Pandorabox</tag>
      
      <tag>shadowsocks</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Material Design Support Library的侧滑抽屉教程</title>
    <link href="/2015/08/12/NavigationView/"/>
    <url>/2015/08/12/NavigationView/</url>
    
    <content type="html"><![CDATA[<h3 id="Navigation-View-Material-Design-Support-Library-Tutorial"><a href="#Navigation-View-Material-Design-Support-Library-Tutorial" class="headerlink" title="Navigation View - Material Design Support Library Tutorial"></a>Navigation View - Material Design Support Library Tutorial</h3><p><em>原文<a href="http://www.android4devs.com/2015/06/navigation-view-material-design-support.html?showComment=1433727371964#c1932522776365289504" target="_blank" rel="noopener">地址</a>（需自备梯子）</em><br><em>原作者: Akash bangad</em><br><em>译者: ZubinXiong</em><br><br><em>注：本文的翻译已获得原作者许可，转载此文章请附上原文链接以及此文链接。因个人翻译水平有限，难免文中有少许错误，请各位批评指教</em></p><p>Google几天前在2015年的Google IO大会上发布了新的Material Design Support Library(Material Design 支持库)，今天我们将看一看支持库中的一个组件即Navigation View(抽屉组件)，有了这个新组件，想要制作一个符合Material Design的漂亮的抽屉导航将非常容易，在这个支持库出来之前我已经展示过如何制作Navigation drawer，这项工作非常烦人，但是如果使用今天这个Support Library一切都变的非常容易。所以让我们开始吧。</p><a id="more"></a><h4 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h4><p>这篇教程将要使用toolbar代替actionbar，如果你对的如何使用toolbar并不熟悉，你最好在开始这篇教程之前先熟悉下我之前的Toolbar教程。这并非必要的但是我还是强烈的建议你先了解一些toolbar。</p><h4 id="必备条件"><a href="#必备条件" class="headerlink" title="必备条件"></a>必备条件</h4><ol><li><p>Android Studio 1.3 （这篇教程使用1.3的版本）</p></li><li><p>Circle Image Library (把下方的依赖添加到gradle文件中)<br><br><font color="orange"><em>compile ‘de.hdodenhof:circleimageview:1.3.0’</em></font></p></li><li><p>Material Design Support Library （把下方的依赖添加到gradle文件中）<br><br><font color="orange"><em>compile ‘com.android.support:design:22.2.0</em></font></p><p>在我之前的那边教程中，我已经解释过了 DrawerLayout 是如何工作的。在这篇教程中它将同样在我们的root view（根布局）中使用，因此如果你并不清楚他是如何工作的，那么就赶紧先去读一下这部分内容，之前这篇教程的链接在这 - <a href="http://www.android4devs.com/2014/12/how-to-make-material-design-navigation-drawer.html" target="_blank" rel="noopener">How To Make Navigation Drawer With Header View</a></p></li></ol><h4 id="了解-Navigation-View"><a href="#了解-Navigation-View" class="headerlink" title="了解 Navigation View"></a>了解 Navigation View</h4><p><img src="http://7xjkin.com1.z0.glb.clouddn.com/2.1.jpg" srcset="/img/loading.gif" alt=""></p><p>把 NavigationView 和一些你知道其他View进行对比你就会知道，你可以根据自己的需求把 Navigation View 分成两部分，即下方所述:</p><h5 id="顶部View"><a href="#顶部View" class="headerlink" title="顶部View"></a>顶部View</h5><p>这部分视图基本上是抽屉内容的最上方，他包括用户的头像照片，姓名以及邮箱等。你需要把这部分内容定义在一个单独的布局中，我们稍后便会来查看这一部分内容。</p><h5 id="抽屉菜单"><a href="#抽屉菜单" class="headerlink" title="抽屉菜单"></a>抽屉菜单</h5><p>这部分菜单是你接着顶部View想要显示的内容，我们在menus文件夹下定义这些文件，就像你定义在overflow中的menu一样。<br><br>因此 NavigationView 通常是你想要在侧滑抽屉中使用的顶部View和抽屉菜单的集合。现在你应该明白了NavigationView 我们可以开始构建我们的Navigation Drawer了。</p><p>在我们开始创建app前先让我们看一看我们准备打造的软件的样子，看看下方的gif图片你能够看到我们打算建造一个侧滑抽屉同时当我们点击 inbox 选项的时候软件中打开相应的 Inbox fragment 页面，当你点击其他选项的时候我们用一个吐司(Toast)信息显示已经接收到了单击事件。<br><img src="http://7xjkin.com1.z0.glb.clouddn.com/2.2.gif" srcset="/img/loading.gif" alt=""></p><h4 id="使用-Navigation-View-建造-Navigation-Drawer-的步骤"><a href="#使用-Navigation-View-建造-Navigation-Drawer-的步骤" class="headerlink" title="使用 Navigation View 建造 Navigation Drawer 的步骤"></a>使用 Navigation View 建造 Navigation Drawer 的步骤</h4><ol><li><p>打开Android Studio 新建一个空的项目，当你的项目建好后就去给你的软件创建一个颜色体系(Color scheme)。 创建的方法是在res -&gt; values 目录下新建一个 colors.xml 文件。现在快去把这几行代码添加到你的colors.xml文件中，关于这些颜色的作用我在之前的Toolbar 教程中已经解释过了，此处不在。<br></p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;color name=&quot;PrimaryColor&quot;&gt;#2196F3&lt;/color&gt; &lt;color name=&quot;PrimaryDarkColor&quot;&gt;#1976D2&lt;/color&gt;&lt;/resources&gt;</code></pre></li><li><p>现在让我们给app定义样式(style), 打开在project 目录下位于 res -&gt; values 文件夹中的 styles.xml 文件。添加下属这些代码到文件中，我们已经为整个app设置好了颜色体系，同时注意我们让 status bar的颜色变透明了，这些都是为了实现我们预期的效果。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;     &lt;item name=&quot;android:colorPrimary&quot;&gt;@color/PrimaryColor&lt;/item&gt;     &lt;item name=&quot;android:colorPrimaryDark&quot;&gt;@color/PrimaryDarkColor&lt;/item&gt;     &lt;item name=&quot;android:statusBarColor&quot;&gt;@android:color/transparent&lt;/item&gt;     &lt;!-- Customize your theme here. --&gt; &lt;/style&gt;&lt;/resources&gt;</code></pre></li><li><p>现在让我们开始实现navigation drawer 中顶部的样子, 因此我们首先需要新建一个layout 资源并把它命名为header.xml。 添加下述代码到文件中，我们的顶部布局使用RelativeLayout作为根布局，其中有三个view: 一个是圆形的ImageView用来显示用户头像，两个textview用来显示邮箱和姓名。同时我已经把用于显圆形头像的图片文件放到了drawable文件夹。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;190dp&quot; android:background=&quot;@drawable/background_material&quot; android:orientation=&quot;vertical&quot; &gt; &lt;de.hdodenhof.circleimageview.CircleImageView xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/profile_image&quot; android:layout_width=&quot;76dp&quot; android:layout_height=&quot;76dp&quot; android:src=&quot;@drawable/profile&quot; app:border_color=&quot;#FF000000&quot; android:layout_marginLeft=&quot;24dp&quot; android:layout_centerVertical=&quot;true&quot; android:layout_alignParentLeft=&quot;true&quot; android:layout_alignParentStart=&quot;true&quot; android:layout_marginStart=&quot;24dp&quot; /&gt; &lt;TextView     android:layout_width=&quot;wrap_content&quot;     android:layout_height=&quot;wrap_content&quot;     android:text=&quot;Akash Bangad&quot;     android:textSize=&quot;14sp&quot;     android:textColor=&quot;#FFF&quot;     android:textStyle=&quot;bold&quot;     android:gravity=&quot;left&quot;     android:paddingBottom=&quot;4dp&quot;     android:id=&quot;@+id/username&quot;     android:layout_above=&quot;@+id/email&quot;     android:layout_alignLeft=&quot;@+id/profile_image&quot;     android:layout_alignStart=&quot;@+id/profile_image&quot; /&gt; &lt;TextView     android:layout_width=&quot;wrap_content&quot;     android:layout_height=&quot;wrap_content&quot;     android:text=&quot;Akash.bangad93@gmail.com&quot;     android:id=&quot;@+id/email&quot;     android:gravity=&quot;left&quot;     android:layout_marginBottom=&quot;8dp&quot;     android:textSize=&quot;14sp&quot;     android:textColor=&quot;#fff&quot;     android:layout_alignParentBottom=&quot;true&quot;     android:layout_alignLeft=&quot;@+id/username&quot;     android:layout_alignStart=&quot;@+id/username&quot; /&gt;</code></pre></li></ol></RelativeLayout>```<ol start="4"><li><p>完成了顶部view之后现在该轮到我们的抽屉菜单了，因此我们现在去到 res -&gt; menu 文件夹中并新建一个menu 源文件并把它命名为drawer.xml 同时把下列代码加到你的文件中。每个menu选项使用<item>标签关闭，同是我们将这些item 用<group>标签闭合起来并设置  android:cheakableBehavour=”single” 以保证每次点击只有一个item能够被选中。icon标签表示的是我们想要在menu文字前显示的图标，关于图标源文件我已经从 <a href="http://www.google.com/design/icons" target="_blank" rel="noopener">www.google.com/design/icons</a> 中下载并放到我的drawable 文件夹中了。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;group android:checkableBehavior=&quot;single&quot;&gt;     &lt;item         android:id=&quot;@+id/inbox&quot;         android:checked=&quot;false&quot;         android:icon=&quot;@drawable/ic_inbox_black&quot;         android:title=&quot;@string/inbox_string&quot; /&gt;     &lt;item         android:id=&quot;@+id/starred&quot;         android:checked=&quot;false&quot;         android:icon=&quot;@drawable/ic_star_black&quot;         android:title=&quot;@string/starred_string&quot; /&gt;     &lt;item         android:id=&quot;@+id/sent_mail&quot;         android:checked=&quot;false&quot;         android:icon=&quot;@drawable/ic_send_black&quot;         android:title=&quot;@string/sent_mail_string&quot; /&gt;     &lt;item         android:id=&quot;@+id/drafts&quot;         android:checked=&quot;false&quot;         android:icon=&quot;@drawable/ic_drafts_black&quot;         android:title=&quot;@string/draft_string&quot; /&gt;</code></pre></li></ol><pre><code>    &lt;item        android:id=&quot;@+id/allmail&quot;        android:checked=&quot;false&quot;        android:icon=&quot;@drawable/ic_email_black&quot;        android:title=&quot;@string/all_mail_string&quot; /&gt;    &lt;item        android:id=&quot;@+id/trash&quot;        android:checked=&quot;false&quot;        android:icon=&quot;@drawable/ic_delete_black&quot;        android:title=&quot;@string/trash_string&quot; /&gt;    &lt;item        android:id=&quot;@+id/spam&quot;        android:checked=&quot;false&quot;        android:icon=&quot;@drawable/ic_error_black&quot;        android:title=&quot;@string/spam_string&quot; /&gt;&lt;/group&gt;</code></pre></menu>```5. 现在我们的顶部view 和抽屉菜单都已经创建好了，现在我们可以开始完成 main_activity.xml文件了，因此我们打开我们的 main_activity.xml 文件并把下面的这些代码加到里面，正如你所看到的我们使用DrawerLayout 作为我们的根布局并且他有两个子布局，第一个表示的是我们app内容采用线性布局，同时我们把toolbar 以及 framelayout 放在了线性布局中。Drawerlayout的第二个子布局就是我们打算放Navigation View的侧滑抽屉。下列这些属性帮我们把顶部view和抽屉菜单联系在了一起并放在了navigation view中。设置 gravity start 属性是的抽屉从左边滑出。同时注意到我们设置了android:fitsSystemWindows="true"  属性为了让我们的drawerlayout能够实现滑出时state bar能够透明现实的效果。<br>*app:headerLayout="@layout/header"* <br>*app:menu="@menu/drawer"* <br>*android:layout_gravity="start"*<br>*rest of the code is self explanatory.* <br>```xml<android.support.v4.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android"    xmlns:tools="http://schemas.android.com/tools"    xmlns:app="http://schemas.android.com/apk/res-auto"    android:id="@+id/drawer"    android:layout_width="match_parent"    android:layout_height="match_parent"    android:fitsSystemWindows="true"    tools:context=".MainActivity"><pre><code>&lt;LinearLayout    android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    &gt;    &lt;include        android:id=&quot;@+id/toolbar&quot;        layout=&quot;@layout/tool_bar&quot;    /&gt;    &lt;FrameLayout        android:id=&quot;@+id/frame&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;&gt;    &lt;/FrameLayout&gt;&lt;/LinearLayout&gt;&lt;android.support.design.widget.NavigationView    android:id=&quot;@+id/navigation_view&quot;    android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_gravity=&quot;start&quot;    app:headerLayout=&quot;@layout/header&quot;    app:menu=&quot;@menu/drawer&quot;    /&gt;</code></pre><p>&lt;/android.support.v4.widget.DrawerLayout&gt;</p><pre><code>6. 现在我打算创建一个fragment来演示当你点击抽屉中菜单选项时该如何替换app中主内容区域的fragment，因此我们现在去创建一个新的layout给fragment并把它命名为content_fragment.xml。添加下面这些代码到其中(仅仅只是在relative layout中包含了一个 TextView)。```xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;TextView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;INBOX&quot;        android:padding=&quot;8dp&quot;        android:textColor=&quot;#fff&quot;        android:background=&quot;@color/PrimaryColor&quot;        android:textSize=&quot;28sp&quot;        android:id=&quot;@+id/textView&quot;        android:layout_centerVertical=&quot;true&quot;        android:layout_centerHorizontal=&quot;true&quot; /&gt;&lt;/RelativeLayout&gt;</code></pre><ol start="7"><li>现在去Java-&gt; [app包名]下面为fragment创建一个新的类，我把它命名为我的ContentFragment，把下面这些添加到其中，代码相当简单，因为我们已经有了fragment。<pre><code class="Java">package com.android4dev.navigationview;import android.os.Bundle;import android.support.annotation.Nullable;import android.support.v4.app.Fragment;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;</code></pre></li></ol><p>/**</p><ul><li><p>Created by Admin on 04-06-2015.</p></li><li><p>/<br>public class ContentFragment extends Fragment {</p><p>  @Nullable<br>  @Override<br>  public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {</p><pre><code>  View v = inflater.inflate(R.layout.content_fragment,container,false);  return v;</code></pre><p>  }<br>}</p><pre><code>8. 现在我们终于到了给MainActivity.java中添加代码的时候了,我们把下列代码加到其中，我已经对其中一些进行注释来帮助你的理解。```Javapackage com.android4dev.navigationview;</code></pre></li></ul><p>import android.app.FragmentManager;<br>import android.app.FragmentTransaction;<br>import android.graphics.Bitmap;<br>import android.graphics.BitmapFactory;<br>import android.os.AsyncTask;<br>import android.support.design.widget.NavigationView;<br>import android.support.v4.widget.DrawerLayout;<br>import android.support.v7.app.ActionBarDrawerToggle;<br>import android.support.v7.app.AppCompatActivity;<br>import android.os.Bundle;<br>import android.support.v7.widget.Toolbar;<br>import android.util.Log;<br>import android.view.LayoutInflater;<br>import android.view.Menu;<br>import android.view.MenuItem;<br>import android.view.SubMenu;<br>import android.view.View;<br>import android.widget.Toast;</p><p>public class MainActivity extends AppCompatActivity {</p><pre><code>//Defining Variablesprivate Toolbar toolbar;private NavigationView navigationView;private DrawerLayout drawerLayout;@Overrideprotected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);    // Initializing Toolbar and setting it as the actionbar    toolbar = (Toolbar) findViewById(R.id.toolbar);    setSupportActionBar(toolbar);    //Initializing NavigationView    navigationView = (NavigationView) findViewById(R.id.navigation_view);    //Setting Navigation View Item Selected Listener to handle the item click of the navigation menu    navigationView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() {        // This method will trigger on item Click of navigation menu        @Override        public boolean onNavigationItemSelected(MenuItem menuItem) {            //Checking if the item is in checked state or not, if not make it in checked state            if(menuItem.isChecked()) menuItem.setChecked(false);            else menuItem.setChecked(true);            //Closing drawer on item click            drawerLayout.closeDrawers();            //Check to see which item was being clicked and perform appropriate action            switch (menuItem.getItemId()){                //Replacing the main content with ContentFragment Which is our Inbox View;                case R.id.inbox:                    Toast.makeText(getApplicationContext(),&quot;Inbox Selected&quot;,Toast.LENGTH_SHORT).show();                    ContentFragment fragment = new ContentFragment();                    android.support.v4.app.FragmentTransaction fragmentTransaction = getSupportFragmentManager().beginTransaction();                    fragmentTransaction.replace(R.id.frame,fragment);                    fragmentTransaction.commit();                    return true;                // For rest of the options we just show a toast on click                case R.id.starred:                    Toast.makeText(getApplicationContext(),&quot;Stared Selected&quot;,Toast.LENGTH_SHORT).show();                    return true;                case R.id.sent_mail:                    Toast.makeText(getApplicationContext(),&quot;Send Selected&quot;,Toast.LENGTH_SHORT).show();                    return true;                case R.id.drafts:                    Toast.makeText(getApplicationContext(),&quot;Drafts Selected&quot;,Toast.LENGTH_SHORT).show();                    return true;                case R.id.allmail:                    Toast.makeText(getApplicationContext(),&quot;All Mail Selected&quot;,Toast.LENGTH_SHORT).show();                    return true;                case R.id.trash:                    Toast.makeText(getApplicationContext(),&quot;Trash Selected&quot;,Toast.LENGTH_SHORT).show();                    return true;                case R.id.spam:                    Toast.makeText(getApplicationContext(),&quot;Spam Selected&quot;,Toast.LENGTH_SHORT).show();                    return true;                default:                    Toast.makeText(getApplicationContext(),&quot;Somethings Wrong&quot;,Toast.LENGTH_SHORT).show();                    return true;            }        }    });    // Initializing Drawer Layout and ActionBarToggle    drawerLayout = (DrawerLayout) findViewById(R.id.drawer);    ActionBarDrawerToggle actionBarDrawerToggle = new ActionBarDrawerToggle(this,drawerLayout,toolbar,R.string.openDrawer, R.string.closeDrawer){        @Override        public void onDrawerClosed(View drawerView) {            // Code here will be triggered once the drawer closes as we dont want anything to happen so we leave this blank            super.onDrawerClosed(drawerView);        }        @Override        public void onDrawerOpened(View drawerView) {            // Code here will be triggered once the drawer open as we dont want anything to happen so we leave this blank            super.onDrawerOpened(drawerView);        }    };    //Setting the actionbarToggle to drawer layout    drawerLayout.setDrawerListener(actionBarDrawerToggle);    //calling sync state is necessay or else your hamburger icon wont show up    actionBarDrawerToggle.syncState();}@Overridepublic boolean onCreateOptionsMenu(Menu menu) {    // Inflate the menu; this adds items to the action bar if it is present.    getMenuInflater().inflate(R.menu.menu_main, menu);    return true;}@Overridepublic boolean onOptionsItemSelected(MenuItem item) {    // Handle action bar item clicks here. The action bar will    // automatically handle clicks on the Home/Up button, so long    // as you specify a parent activity in AndroidManifest.xml.    int id = item.getItemId();    //noinspection SimplifiableIfStatement    if (id == R.id.action_settings) {        return true;    }    return super.onOptionsItemSelected(item);}</code></pre><p>}</p><pre><code>9. 现在我们终于完成了，如果你正确的跟着这篇教程完成的话，你现在应该已经能够像下面那张图一样运行起来你的app了！&lt;br&gt;![](http://7xjkin.com1.z0.glb.clouddn.com/2.2.gif)##### [GitHub - Download Project](https://github.com/AkashBang/NavigationView)-------------译者：之所以翻译这篇文章，是因为DrawerLayout这是非常常用的内容，而在国内却又一直没有找到很好的教程，刚好在Google的时候找到了这一篇文章，所以就翻译过来了，希望能够给国内的一些初学者一些帮助！</code></pre>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Material Design</tag>
      
      <tag>翻译</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2015/08/01/hello-world/"/>
    <url>/2015/08/01/hello-world/</url>
    
    <content type="html"><![CDATA[<p>#####欢迎来到我的博客</p><ul><li>整个站点是挂在github上的（<del>访问慢请问候方校长</del>）</li><li>DNS解析服务用的dnspod免费服务</li><li>图床用的七牛免费服务，够大而且还挺不错</li><li>域名从<a href="https://www.godaddy.com/" target="_blank" rel="noopener">狗爹</a>那买的</li><li>博客用的hexo，主题变了好几次，具体看右下角<br><br>目前基本功能已经完善，但是RSS输出好像还有点问题，等之后再补充吧（<del>懒癌晚期</del>）</li></ul><hr><h5 id="建站原因"><a href="#建站原因" class="headerlink" title="建站原因"></a>建站原因</h5><ol><li><p>一个最重要的原因就是觉得自己过去太过颓废吧，毕业快一年了，毕业的时候完全没有做过职业规划就糊里糊涂的进了一家地产公司，做着和互联网几乎不相关的工作，可是还是爱不起来。所以还是准备回到互联网的行业，毕竟自己的兴趣点在这，所以在建了这个博客。</p><a id="more"></a></li><li><p>另一个原因受到这几篇博客的影响：<a href="http://36kr.com/p/218600.html" target="_blank" rel="noopener">为什么软件工程师应该养成写作的习惯？</a>  、<a href="http://mindhacks.cn/2011/11/04/how-to-interview-a-person-for-two-years/" target="_blank" rel="noopener">怎样花两年时间去面试一个人</a> 还有一些就不一一列出了，这几篇文章里面指出的关于博客对书写能力以及对自己学习的总结是非常有意义的。</p></li><li><p>最后就是为了督促自己的，之前在CSDN和博客园都有写过，但是都没有坚持下来（<del>毕竟花了钱的，总得多写几篇文章</del>）,而且这些定制起来也麻烦，所以就重新自建了一个。</p></li></ol><hr><h5 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h5><p>关于下半年的学习计划及书单做个清单供自己随时查看</p><ul><li><a href="http://book.douban.com/subject/25965995/" target="_blank" rel="noopener">《构建之法》</a> 软件工程</li></ul><ul><li><p><a href="https://www.udacity.com/course/gradle-for-android-and-java--ud867" target="_blank" rel="noopener">Gradle for Android and Java</a> Google 和 Udacity 推出的关于Gradle课程，刚好学习一下。</p></li><li><p>Effective Java </p></li><li><p>深入了解View的相关知识，对自定义View的使用还不太了解</p></li><li><p>阅读Efficient Android Threading</p></li><li><p>Python核心编程， 只会一门编程语言的开发者我认为是不合格的，多学些东西也不错。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hello world</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
